<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNEToolkit</name>
    </assembly>
    <members>
        <member name="F:DotNEToolkit.BlockState.Used">
            <summary>
            使用中..
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlockState.Unused">
            <summary>
            未使用..
            </summary>
        </member>
        <member name="T:DotNEToolkit.ByteBlock">
            <summary>
            存储一段缓存的字节数组
            </summary>
        </member>
        <member name="P:DotNEToolkit.ByteBlock.AllocateFromBucket">
            <summary>
            该block是否是从bucket里分配的
            </summary>
        </member>
        <member name="P:DotNEToolkit.ByteBlock.State">
            <summary>
            表示该段内存的状态
            暂时未用到
            </summary>
        </member>
        <member name="P:DotNEToolkit.ByteBlock.Data">
            <summary>
            存储该段缓存数据的字节数组的引用
            </summary>
        </member>
        <member name="P:DotNEToolkit.ByteBlock.Size">
            <summary>
            该段缓存数据的长度
            </summary>
        </member>
        <member name="F:DotNEToolkit.ByteBucket.numblk">
            <summary>
            当前block的数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.ByteBucket.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="blockSize">每个内存块的大小</param>
            <param name="numberOfBlock">为该内存池有多少个内存块</param>
        </member>
        <member name="T:DotNEToolkit.BytePool">
            <summary>
            Byte数组的缓存池
            实现思路：
            预先分配一块超大的byte数组，然后通过数据所在byte数组的偏移量和数据大小来确定每一块数据的位置
            </summary>
        </member>
        <member name="M:DotNEToolkit.BytePool.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="maxArrayLength">block的最大长度</param>
            <param name="maxArraysPerBucket">每个bucket里的block的数量，如果这个数量不够用的，那么就直接再开辟一段新的内存空间返回</param>
        </member>
        <member name="M:DotNEToolkit.BytePool.Create(System.Int32,System.Int32)">
            <summary>
            创建一个新的字节缓存池
            </summary>        
            <param name="maxArrayLength">block的最大长度</param>
            <param name="maxArraysPerBucket">每个bucket里的block的数量，如果这个数量不够用的，那么就直接再开辟一段新的内存空间返回</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.BytePool.SelectBucketIndex(System.Int32)">
            <summary>
            根据bufferSize计算bucket的索引
            </summary>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.BytePool.GetMaxSizeForBucket(System.Int32)">
            <summary>
            根据bucket索引计算bucket里的每个block的大小
            </summary>
            <param name="binIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.BytePool.Obtain(System.Int32)">
            <summary>
            从缓存池里获取一个缓存的字节数组
            如果缓存里没有数据了，那么会自动扩容
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.BytePool.Recycle(DotNEToolkit.ByteBlock)">
            <summary>
            回收一个用完了的字节数组
            </summary>
            <param name="block"></param>
        </member>
        <member name="T:DotNEToolkit.Crypto.CRC">
            <summary>
            CRC校验
            </summary>
        </member>
        <member name="M:DotNEToolkit.Crypto.CRC.StringToHexByte(System.String)">
            <summary>
            字符串转16进制字符数组
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Crypto.CRC.StringToHexByte(System.String,System.Boolean)">
            <summary>
            字符串转16进制字符数组
            </summary>
            <param name="str"></param>
            <param name="isFilterChinese">是否过滤掉中文字符</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Crypto.AbstractCryptor">
            <summary>
            加解密抽象类
            </summary>
        </member>
        <member name="P:DotNEToolkit.Crypto.AbstractCryptor.SupportDecrypto">
            <summary>
            加密算法是否支持解密
            </summary>
        </member>
        <member name="P:DotNEToolkit.Crypto.AbstractCryptor.EncryptoKey">
            <summary>
            加解密用到的Key
            </summary>
        </member>
        <member name="P:DotNEToolkit.Crypto.AbstractCryptor.DecryptoKey">
            <summary>
            解密用到的Key
            </summary>
        </member>
        <member name="M:DotNEToolkit.Crypto.AbstractCryptor.Encrypto">
            <summary>
            加密操作
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Crypto.AbstractCryptor.EncryptoBase64">
            <summary>
            加密后的数据进行Base64处理
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Crypto.AbstractCryptor.Decrypto(System.Byte[])">
            <summary>
            解密操作
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DataModels.BizModel">
            <summary>
            存储业务相关的数据模型
            也可以看成是运行时数据模型
            
            业务模型在软件设计中的层次结构：
            DataBase -> DataModel -> BizModel -> AppLogic
            </summary>
        </member>
        <member name="T:DotNEToolkit.DataModels.ModelBaseInt">
            <summary>
            ID是int类型的数据模型
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBaseInt.ID">
            <summary>
            唯一编号
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBaseInt.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBaseInt.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBaseInt.CreationTime">
            <summary>
            创建时间
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBaseInt.Creator">
            <summary>
            创建者
            </summary>
        </member>
        <member name="T:DotNEToolkit.DataModels.ModelBase">
            <summary>
            通用的数据模型基类
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.ID">
            <summary>
            唯一编号
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.CreationTime">
            <summary>
            创建时间
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.Creator">
            <summary>
            创建者
            </summary>
        </member>
        <member name="T:DotNEToolkit.DateTimeFormat">
            <summary>
            提供日期格式化字符串
            </summary>
        </member>
        <member name="F:DotNEToolkit.DateTimeFormat.yyyyMMddhhmmss">
            <summary>
            格式化成202008180927的格式
            </summary>
        </member>
        <member name="T:DotNEToolkit.DbConnectionString">
            <summary>
            定义各种数据库连接字符串模板
            </summary>
        </member>
        <member name="F:DotNEToolkit.DbConnectionString.MysqlFormat">
            <summary>
            Mysql格式的数据库连接字符串模板
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_LOCHARDWARE">
            <summary>
            缓冲区存储在声卡里, 混音是在声卡里做的
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_LOCSOFTWARE">
            <summary>
            缓冲区存储在内存里, 混音是CPU做的
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRL3D">
            <summary>
            The sound source can be moved in 3D space. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLFREQUENCY">
            <summary>
            可以控制声音的频率
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLPAN">
            <summary>
            The sound source can be moved from left to right. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLVOLUME">
            <summary>
            可获取或设置音量大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLPOSITIONNOTIFY">
            <summary>
            缓冲区通知功能
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLFX">
            <summary>
            Effects can be added to the buffer. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_GLOBALFOCUS">
            <summary>
            失去焦点继续播放功能
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBPLAY.DSBPLAY_LOOPING">
            <summary>
            缓冲区播放完毕之后从缓冲区开始的位置继续播放, 当播放主缓冲区的时候必须设置DSBPLAY_LOOPING
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBUFFERDESC.dwBufferBytes">
            <summary>
            播放或者捕获缓冲区大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwFlags">
            <summary>
            指定设备能力, 可以为0, 
            DSCBCAPS_CTRLFX:（支持音效的Buffer）
            只支持从DirectSoundCaptureCreate8函数创建的设备对象, 需要WindowsXP版本（Capture effects require Microsoft Windows XP）
            DSCBCAPS_WAVEMAPPED（The Win32 wave mapper will be used for formats not supported by the device.）
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwBufferBytes">
            <summary>
            捕获缓冲区大小, 字节为单位
            缓冲区大小设置为传输速率, 那么每一个缓冲区就存储了一秒钟的声音数据
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwReserved">
            <summary>
            保留字段, 供以后使用
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.lpwfxFormat">
            <summary>
            要捕获的波形声音的格式信息
            tWAVEFORMATEX结构体指针
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwFXCount">
            <summary>
            一定为0, 除非dwFlag字段设置了DSCBCAPS_CTRLFX标志
            </summary>
        </member>
        <member name="T:DotNEToolkit.DirectSound.DSERR">
            <summary>
            DirectSound return values
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_NORMAL">
            <summary>
            Sets the normal level. This level has the smoothest multitasking and resource-sharing behavior, but because it does not allow the primary buffer format to change, output is restricted to the default 8-bit format. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_PRIORITY">
            <summary>
            Sets the priority level. Applications with this cooperative level can call the SetFormat and Compact methods. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_EXCLUSIVE">
            <summary>
            For DirectX 8.0 and later, has the same effect as DSSCL_PRIORITY. For previous versions, sets the application to the exclusive level. This means that when it has the input focus, the application will be the only one audible; sounds from applications with the DSBCAPS_GLOBALFOCUS flag set will be muted. With this level, it also has all the privileges of the DSSCL_PRIORITY level. DirectSound will restore the hardware format, as specified by the most recent call to the SetFormat method, after the application gains the input focus. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_WRITEPRIMARY">
            <summary>
            Sets the write-primary level. The application has write access to the primary buffer. No secondary buffers can be played. This level cannot be set if the DirectSound driver is being emulated for the device; that is, if the GetCaps method returns the DSCAPS_EMULDRIVER flag in the DSCAPS structure. 
            </summary>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundBuffer8.Lock(System.UInt32,System.UInt32,System.IntPtr@,System.UInt32@,System.IntPtr@,System.UInt32@,System.UInt32)">
            <summary>
            
            </summary>
            <param name="dwOffset">Offset, in bytes, from the start of the buffer to the point where the lock begins. This parameter is ignored if DSBLOCK_FROMWRITECURSOR is specified in the dwFlags parameter. </param>
            <param name="dwBytes"></param>
            <param name="ppvAudioPtr1"></param>
            <param name="pdwAudioBytes1"></param>
            <param name="ppvAudioPtr2"></param>
            <param name="pdwAudioBytes2"></param>
            <param name="dwFlags">
            DSBLOCK_FROMWRITECURSOR : Start the lock at the write cursor. The dwOffset parameter is ignored.
            DSBLOCK_ENTIREBUFFER : Lock the entire buffer. The dwBytes parameter is ignored.
            </param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundBuffer8.Play(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="dwReserved1">必须为0</param>
            <param name="dwPriority">声音优先级, 当分配硬件混合资源的时候用来管理声音, 最低级别为0, 最高级别0xFFFFFFFF, 如果缓冲区创建的时候没有设置DSBCAPS_LOCDEFER标志, 那么取值必须为0</param>
            <param name="dwFlags"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundCapture8.GetCaps(DotNEToolkit.DirectSound.DSCCAPS@)">
            <summary>
            获取捕获音频设备的信息
            </summary>
            <param name="pDSCCaps">DSCCAPS结构体指针, 必须指定dwSize字段</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundCaptureBuffer8.GetCurrentPosition(System.Int32@,System.Int32@)">
            <summary>
            获取当前捕获位置
            </summary>
            <param name="pdwCapturePosition">Capture指针在缓冲中的位置</param>
            <param name="pdwReadPosition">Read指针在缓冲中的位置</param>
            <remarks>
            Read指针是指名当前你可以读到哪个位置，而不是从哪个位置开始读，比如第一次取数据的时候，会取缓冲的最开始位置到Read指针所指的位置。
            又由于是一个环形的缓冲，所以Capture指针的位置不一定总是大于Read指针的，可以理解成，Capture表明了在调用这个函数时正在录取的数据将要写到（为止）的位置，而Read是已经写好了的到这个位置为止的位置。
            所以我们在读取数据的时候要保存一个偏移量，记录每次要读取的数据的起始位置
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundCaptureBuffer8.Lock(System.UInt32,System.UInt32,System.IntPtr@,System.Int32@,System.IntPtr@,System.Int32@,System.Int32)">
            <summary>
            The Lock method locks a portion of the buffer. Locking the buffer returns pointers into the buffer, allowing the application to read or write audio data into memory.
            </summary>
            <param name="dwOffset">Offset, in bytes, from the start of the buffer to the point where the lock begins. </param>
            <param name="dwBytes">Size, in bytes, of the portion of the buffer to lock. Because the buffer is conceptually circular, this number can exceed the number of bytes between dwOffset and the end of the buffer. </param>
            <param name="ppvAudioPtr1"></param>
            <param name="pdwAudioBytes1"></param>
            <param name="ppvAudioPtr2"></param>
            <param name="pdwAudioBytes2"></param>
            <param name="dwFlags">Flags modifying the lock event. This value can be zero or the following flag: DSCBLOCK_ENTIREBUFFER  Ignore dwBytes and lock the entire capture buffer.  </param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nChannels">
            <summary>
            通道数量
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nSamplesPerSec">
            <summary>
            采样率, 每秒采样次数
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nAvgBytesPerSec">
            <summary>
            设置声音数据的传输速率, 每秒平均传输的字节数, 单位byte/s, 如果wFormatTag = WAVE_FORMAT_PCM, nAvgBytesPerSec为nBlockAlign * nSamplesPerSec, 对于非PCM格式请根据厂商的说明计算
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nBlockAlign">
            <summary>
            以字节为单位设置块对齐。块对齐是指最小数据的原子大小，如果wFormatTag = WAVE_FORMAT_PCM, nBlockAlign为(nChannels * wBitsPerSample) / 8, 对于非PCM格式请根据厂商的说明计算
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.wBitsPerSample">
            <summary>
            采样位数, 每个采样的位数
            如果wFormatTag是WAVE_FORMAT_PCM, 必须设置为8或者16, 其他的不支持
            如果wFormatTag是WAVE_FORMAT_EXTENSIBLE, 必须设置为8的倍数, 一些压缩方法不定义此值, 所以此值可以为0
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.cbSize">
            <summary>
            额外信息的大小，以字节为单位，额外信息添加在WAVEFORMATEX结构的结尾。这个信息可以作为非PCM格式的wFormatTag额外属性，如果wFormatTag不需要额外的信息，此值必需为0，对于PCM格式此值被忽略。
            </summary>
        </member>
        <member name="T:DotNEToolkit.Colors">
            <summary>
            提供颜色转换函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Colors.ConvertRGB(System.String,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            十六进制的颜色转rgb
            支持以井号开头或者不以井号开头的十六进制颜色值
            </summary>
            <param name="color"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name=""></param>
        </member>
        <member name="T:DotNEToolkit.Media.Video.VideoDecodeType">
            <summary>
            视频解码器类型
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Video.libvlcPlay">
            <summary>
            封装vlc视频播放器
            调用libvlc_media_player_stop的时候libvlc_media_read_cb必须返回-1，不然会发生死锁现象
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.Video.libvlcPlay.libvlc_media_read_cb(System.IntPtr,System.IntPtr,System.Int32)">
             Callback prototype to read data from a custom bitstream input media.
            
             \param opaque private pointer as set by the @ref libvlc_media_open_cb
                           callback
             \param buf start address of the buffer to read data into
             \param len bytes length of the buffer
            
             \return strictly positive number of bytes read, 0 on end-of-stream,
                     or -1 on non-recoverable error
            
             \note If no data is immediately available, then the callback should sleep.
             \warning The application is responsible for avoiding deadlock situations.
             In particular, the callback should return an error if playback is stopped;
             if it does not return, then libvlc_media_player_stop() will never return.
             
             调用libvlc_media_player_stop的时候libvlc_media_read_cb必须返回-1，不然会发生死锁现象
        </member>
        <member name="T:DotNEToolkit.Media.Video.VideoPlay">
            <summary>
            封装实时视频播放器
            
            1. 视频缓冲区管理
            外部调用的时候，只需要调用PuhData和RequestData就可以了
            当外部调用者收到了视频流的时候，调用PutData把视频流放入缓冲区
            播放器会自动使用缓冲区里的视频流数据
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Video.VideoPlay.EV_EOF">
            <summary>
            视频播放结束
            当播放的是文件的时候，才可能会触发这个事件
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Video.VideoPlayType">
            <summary>
            播放器类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Video.VideoPlayType.libvlc">
            <summary>
            使用libvlc播放
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.MediaPlay.DefaultTimeout">
            <summary>
            默认的播放超时时间是5秒钟
            </summary>
        </member>
        <member name="E:DotNEToolkit.Media.MediaPlay.StatusChanged">
            <summary>
            播放器状态发生改变的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.MediaPlay.timeout">
            <summary>
            播放超时时间
            如果超过这个时间还是没有取到视频流，那么默认超时，采取的操作是关闭播放器
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.MediaPlay.Hwnd">
            <summary>
            渲染视频的窗口句柄
            音频写Inptr.Zero
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.MediaPlay.FileURI">
            <summary>
            指定要播放的文件的路径
            可以是网络路径
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.MediaPlay.Format">
            <summary>
            该播放器支持的格式
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.MediaPlay.PlayStatus">
            <summary>
            当前播放状态
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.MediaPlay.Start">
            <summary>
            开始播放
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.MediaPlay.Stop">
            <summary>
            停止播放
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.MediaPlay.Write(System.Byte[])">
            <summary>
            写入媒体数据
            </summary>
            <param name="videoData"></param>
        </member>
        <member name="T:DotNEToolkit.Media.MediaPlayFactory">
            <summary>
            创建返回值是MediaPlay的播放器实例
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.MediaRecord.Start">
            <summary>
            开始录制
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.MediaRecord.Stop">
            <summary>
            结束录制
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.MediaStream.Size">
            <summary>
            当前的数据总大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.MediaStream.IsClosed">
            <summary>
            流是否被关闭
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.MediaStream.Read(System.Byte[])">
            <summary>
            从缓冲区里拿到小于等于buffer长度的数据
            如果缓冲区里没有数据，那么会返回false，否则返回true
            注意buffer的长度有可能比buffer.Length小
            </summary>
            <param name="buffer">存储视频数据的缓冲区</param>
            <returns>
            0：没取到数据
            大于0：取到的数据大小
            </returns>
        </member>
        <member name="M:DotNEToolkit.Media.MediaStream.Read2(System.Byte[])">
            <summary>
            从缓冲区里拿到等于buffer长度的数据
            如果当前缓冲区的大小小于buffer，那么直接返回0
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.MediaStream.ReadAll">
            <summary>
            一次性读取缓冲区里的所有数据
            如果缓冲区里没有数据，那么返回null
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.MediaStream.Write(System.Byte[])">
            <summary>
            把数据写入缓冲区
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:DotNEToolkit.Media.MediaStream.Clear">
            <summary>
            清空缓冲区中的所有数据
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AVFormats">
            <summary>
            定义音视频格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AVFormats.AV_FORMAT_H264">
            <summary>
            H264视频格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AVFormats.AV_FORMAT_PCM">
            <summary>
            PCM音频原始数据格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AVFormats.AV_FORMAT_G711_ALAW">
            <summary>
            G711音频编码方式
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.AudioPlay">
            <summary>
            一个简单的PCM播放器
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioPlay.Channel">
            <summary>
            采样通道数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioPlay.SamplesPerSec">
            <summary>
            采样率
            每秒钟的采样次数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioPlay.BitsPerSample">
            <summary>
            每个采样大小是16位
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioPlay.BlockAlign">
            <summary>
            块对齐, 每个采样的字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioPlay.BytesPerSec">
            <summary>
            一秒钟音频所占空间大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioPlay.BufferSize">
            <summary>
            捕获缓冲区大小和播放缓冲区大小
            缓冲区里的数据是一秒钟的音频数据
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.AudioPlayType">
            <summary>
            录音机类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioPlayType.DirectSound">
            <summary>
            使用DirectSound播放音频你
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioPlayType.libvlc">
            <summary>
            使用libvlc播放音频
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioPlayType.WaveAPI">
            <summary>
            使用WaveAPI
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.AudioRecordType">
            <summary>
            录音机类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioRecordType.DirectSound">
            <summary>
            使用DirectSound录音
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioRecordType.WaveAPI">
            <summary>
            使用waveIn API录音
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.AudioRecordFactory">
            <summary>
            录音机工厂
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.DirectSoundPlay.syncContext">
            <summary>
            创建DirectSound实例的线程要和播放在同一个线程操作
            不然播放的时候会崩溃，报E_NOINTERFACE的错误
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.WaveAPIRecord">
            <summary>
            使用waveIn API开发的录音程序
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.WaveAPIRecord.free_pwh">
            <summary>
            WaveHeader指针
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.WaveAPIRecord.hwi">
            <summary>
            WaveIn Hwnd
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.AudioDevice">
            <summary>
            表示一个声卡设备
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioDevice.Name">
            <summary>
            声卡设备的显示名字
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.AudioRecord">
            <summary>
            一个录制PCM音频的录音机
            </summary>
        </member>
        <member name="E:DotNEToolkit.Media.Audio.AudioRecord.DataReceived">
            <summary>
            录到了数据会触发
            </summary>
        </member>
        <member name="E:DotNEToolkit.Media.Audio.AudioRecord.Failed">
            <summary>
            当录音过程中遇到错误的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioRecord.filePath">
            <summary>
            要保存的音频文件路径
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioRecord.fileStream">
            <summary>
            保存的音频流文件
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.AudioRecord.usedDevice">
            <summary>
            当前正在使用的声卡设备
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioRecord.Channel">
            <summary>
            采样通道数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioRecord.SamplesPerSec">
            <summary>
            采样率
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioRecord.BitsPerSample">
            <summary>
            每个采样大小是16位
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioRecord.BlockAlign">
            <summary>
            块对齐, 每个采样的字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioRecord.BytesPerSec">
            <summary>
            一秒钟音频所占空间大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.AudioRecord.BufferSize">
            <summary>
            捕获缓冲区大小和播放缓冲区大小
            缓冲区里的数据是一秒钟的音频数据
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.Audio.AudioRecord.Start">
            <summary>
            开始录音
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.Audio.AudioRecord.Stop">
            <summary>
            停止录音
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.Audio.AudioRecord.GetAudioDevices">
            <summary>
            枚举系统里所有的录音设备（可以录音的声卡）
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.Audio.AudioRecord.SetRecordFile(System.String)">
            <summary>
            设置录音文件的保存路径
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:DotNEToolkit.Media.Audio.AudioRecord.SetAudioDevice(DotNEToolkit.Media.Audio.AudioDevice)">
            <summary>
            设置录音程序使用的声卡
            </summary>
            <param name="device"></param>
        </member>
        <member name="T:DotNEToolkit.Media.Audio.DirectSoundRecord">
            <summary>
            DirectSound录音出来的数据是小尾端的数据
            无符号16位数据
            大尾端就是高位在低地址，小尾端就是低位在低地址。
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.Audio.DirectSoundRecord.DirectSoundAudioDevice.ID">
            <summary>
            设备的GUID
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.DirectSoundRecord.NotifyEvents">
            <summary>
            音频缓冲区通知对象的个数
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.DirectSoundRecord.dsc8">
            <summary>
            IDirectSoundCapture8
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.Audio.DirectSoundRecord.dscb8">
            <summary>
            IDirectSoundCaptureBuffer8
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.PCMFormats">
            <summary>
            规定PCM数据的存储格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.PCMFormats.S16_LE">
            <summary>
            有符号16位整数，小尾端
            DirectSound默认存储方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.PCMFormats.S16_BE">
            <summary>
            有符号16位整数，大尾端
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AudioUtils">
            <summary>
            提供音频数据相关的工具函数
            
            分贝是一个相对量，相对于某一个标准值的倍数取对数，得到的就是贝尔Bell，分贝则是贝尔的十分之一。比如以10为标准，那么1000就是2Bell，也就是20dB。
            计算分贝的公式：10 * log10(x / std)
            
            PCM数据存储格式：
            1. 8位单声道：
            2. 8位双声道：
            3. 16位单声道：
            4. 16位双声道：
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.AudioUtils.CalculateDb(System.Byte[],System.Int32,DotNEToolkit.Media.PCMFormats,System.Collections.Generic.List{System.Double}@)">
            <summary>
            计算音频数据的dbFS值
            </summary>
            <param name="channels">PCM数据</param>
            <param name="pcm">通道数</param>
            <param name="formats">PCM数据存储方式</param>
            <param name="volume">声音音量，百分比单位</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Media.G711">
            <summary>
            提供G711数据编解码函数
            
            https://www.jianshu.com/p/33cba1a821d0
            g711a输入的是13位（S16的高13位），这种格式是经过特别设计的，便于数字设备进行快速运算。
            G711的内容是将14bit(uLaw)或者13bit(aLaw)采样的PCM数据编码成8bit的数据流，播放的时候在将此8bit的数据还原成14bit或者13bit进行播放，不同于MPEG这种对于整体或者一段数据进行考虑再进行编解码的做法，G711是波形编解码算法，就是一个sample对应一个编码，所以压缩比固定为：
            8/14 = 57% (uLaw)
            8/13 = 62% (aLaw)
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.G711.Alaw2PCM(System.Byte[],System.Int32)">
            <summary>
            alaw转PCM
            </summary>
            <param name="alaw">G711数据</param>
            <param name="size">要解码的字节数</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.G711.Ulaw2PCM(System.Byte[],System.Int32)">
            <summary>
            ulaw转PCM
            </summary>
            <param name="ulaw"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleInputAttribute">
            <summary>
            定义模块的输入参数
            1. 工作流设计器使用
            2. 方便开发者一眼就可以看到模块有哪些输出值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.Key">
            <summary>
            参数的键
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.ValueType">
            <summary>
            参数类型
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.Description">
            <summary>
            参数描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.Optional">
            <summary>
            该参数是否是可选参数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.IsClass">
            <summary>
            表示该输入是否是一个类类型
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.#ctor(System.String,System.String,System.Type,System.Boolean)">
            <summary>
            
            </summary>
            <param name="description"></param>
            <param name="key"></param>
            <param name="valueType"></param>
            <param name="optional">true：可空，false：不可空</param>
        </member>
        <member name="M:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.#ctor(System.String,System.Type,System.Boolean)">
            <summary>
            当输入是一个类类型使用
            </summary>
            <param name="description"></param>
            <param name="optional"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            当输入是一个属性类型的时候使用
            </summary>
            <param name="description"></param>
            <param name="optional"></param>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModulePropertyAttribute">
            <summary>
            表示一个模块的公开属性
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleActionAttribute">
            <summary>
            表示一个模块的调用操作
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleActionAttribute.Name">
            <summary>
            动作的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleActionAttribute.Manually">
            <summary>
            是否在界面上手动触发
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleInstanceAttribute">
            <summary>
            工作流设计器使用
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleOutputAttribute">
            <summary>
            定义模块的输出数据
            1. 工作流设计器使用
            2. 方便开发者一眼就可以看到模块有哪些输出值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleFactoryOptions.AsyncInitializing">
            <summary>
            是否使用异步加载模块
            默认true
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleFactoryOptions.ModuleList">
            <summary>
            要加载的模块列表
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleFactoryOptions.ReInitializeInterval">
            <summary>
            当初始化某个模块失败的时候，会重新初始化
            这个值指定重新初始化模块的间隔时间，单位是毫秒，默认2000
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.AppModule`1">
            <summary>
            在Module基础上实现一个ModularApp里的Module
            </summary>
            <typeparam name="TApp"></typeparam>
            <typeparam name="TManifest"></typeparam>
        </member>
        <member name="P:DotNEToolkit.Modular.AppModule`1.AppManifest">
            <summary>
            该Module所属的AppManifest
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleEventDlg">
            <summary>
            处理模块事件的委托
            </summary>
            <param name="sender">发布该事件的模块实例</param>
            <param name="eventArgs">事件参数</param>
        </member>
        <member name="T:DotNEToolkit.Modular.EventRollbackDlg">
            <summary>
            当事件执行失败的时候，要执行的回滚操作
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleExtensions">
            <summary>
            模块的附加功能
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleExtensions.SetupWCFHttpService``1(DotNEToolkit.Modular.ModuleBase,System.EventHandler,System.EventHandler,System.ServiceModel.Web.WebServiceHost@)">
            <summary>
            快速初始化一个WCF WebService
            </summary>
            <typeparam name="TServiceContract"></typeparam>
            <param name="webModule"></param>
            <param name="openedDlg"></param>
            <param name="closedDlg"></param>
            <param name="svchost"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.IConfigReader.Initialize(System.String)">
            <summary>
            初始化Reader
            </summary>
            <param name="configPath"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.IConfigReader.ReadValue(System.String)">
            <summary>
            读取配置项
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.IModuleInstance">
            <summary>
            模块实例公共接口
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Status">
            <summary>
            模块状态
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.ID">
            <summary>
            模块ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Name">
            <summary>
            模块名称
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Definition">
            <summary>
            描述文件
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Factory">
            <summary>
            所属的工厂
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.IModuleInstance.Initialize">
            <summary>
            初始化模块
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.IModuleInstance.Release">
            <summary>
            释放模块
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleBase">
            <summary>
            表示一个抽象的模块
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleBase.logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.ModuleBase.OnEvent">
            <summary>
            当有事件触发的时候触发
            int:EventTyep
            object:EventParam
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Status">
            <summary>
            模块当前的状态
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.ID">
            <summary>
            模块ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Name">
            <summary>
            模块名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Description">
            <summary>
            模块的描述信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Definition">
            <summary>
            模块的定义
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Factory">
            <summary>
            模块所属工厂
            在ModuleFactory里被赋值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Properties">
            <summary>
            模块当前的输出参数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.InputParameters">
            <summary>
            模块的输入参数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.Initialize">
            <summary>
            初始化模块
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.Release">
            <summary>
            释放模块占用的资源
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.NotifyEvent(System.Int32,System.Object)">
            <summary>
            通知外部模块有事件触发
            </summary>
            <param name="eventType"></param>
            <param name="eventParam"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.GetParameter``1(System.String,``0)">
            <summary>
            读取该模块的输入参数
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.SetParameter``1(System.String,``0)">
            <summary>
            设置参数
            注意如果设置的参数是类类型，那么会先把类序列化成字符串
            所以不能序列化带有状态的类，只能序列化一些数据模型类
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.OnInitialize">
            <summary>
            子类初始化
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.OnRelease">
            <summary>
            子类释放资源
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleDefinition">
            <summary>
            存储模块的信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.ID">
            <summary>
            模块ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.Name">
            <summary>
            模块名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.MetadataID">
            <summary>
            组件类型ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.ClassName">
            <summary>
            模块的完整类型名
            如果该值不为空，那么优先根据该值去创建实例
            如果该值为空，那么会根据MetadataID去创建实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.Flags">
            <summary>
            模块的标志位
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.InputParameters">
            <summary>
            输入配置参数
            执行模块的构造方法的时候，会动态把所依赖的模块实例反射并赋值给该模块的属性
            避免了每次都要调用LookupModule去查找模块，麻烦
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.HasFlag(System.Int32)">
            <summary>
            判断该模块是否包含指定的选项
            </summary>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.SetFlag(System.Int32)">
            <summary>
            设置该模块的选项
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.CloneInputParameters">
            <summary>
            克隆一份输入参数
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleFactory">
            <summary>
            模块工厂
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.ModuleFactory.Initialized">
            <summary>
            当所有模块都加载完成的时候触发
            只有在异步加载模块的时候才会触发
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.ModuleFactory.ModuleStatusChanged">
            <summary>
            当模块状态改变的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleFactory.moduleList">
            <summary>
            存储已经加载了的模块
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleFactory.MetadataList">
            <summary>
            所有模块的元数据信息
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.InitializeModule(DotNEToolkit.Modular.ModuleBase,System.Int32,DotNEToolkit.Modular.ModuleBase)">
            <summary>
            初始化一个模块，会解析依赖项
            </summary>
            <param name="moduleInst">要初始化的模块</param>
            <param name="interval">
            > 0  : 重新初始化的间隔时间，如果初始化失败，那么会一直初始化
            = -1 : 失败直接返回，不尝试重新初始化
            </param>
            <param name="baseModule">当前初始化的模块</param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateModuleInstance(System.Collections.Generic.IEnumerable{DotNEToolkit.Modular.ModuleDefinition})">
            <summary>
            创建模块的实例
            只创建实例，不调用Initialize方法
            </summary>
            <param name="initialModules"></param>
            <returns>返回创建了的模块个数</returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModuleMetadatas">
            <summary>
            读取所有的类型定义
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateFactory(DotNEToolkit.Modular.ModuleFactoryOptions)">
            <summary>
            创建一个空的工厂
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.Initialize">
            <summary>
            初始化ModuleFactory
            1. 根据Options加载模块
            
            同步加载：如果初始化摸个模块失败，那么就返回FAILED
            异步加载：永远返回SUCCESS
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModule``1(System.String)">
            <summary>
            根据ID查找系统中可用的组件
            如果ID为空，则返回第一个可用的组件
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModule``1">
            <summary>
            查找指定类型的组件，如果有多个，则返回第一个
            </summary>
            <typeparam name="TModuleInstance"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModule(System.Type)">
            <summary>
            根据模块类型获取对应的模块实例
            </summary>
            <param name="targetType">要获取的模块类型</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateModuleInstance">
            <summary>
            创建所有模块的实例
            只创建实例，不初始化
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.InitializeModuleInstance">
            <summary>
            根据同步或者异步配置，来初始化模块
            ModuleFactoryOptions.AsyncInitializing
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleFlags">
            <summary>
            模块的标志位
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleFlags.Disabled">
            <summary>
            模块被禁用
            告诉ModuleFactory不要加载该模块
            该模块不会被加到缓存里
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleStatus">
            <summary>
            表示一个模块的状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.UnInitialized">
            <summary>
            空闲状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.Initialized">
            <summary>
            模块初始化成功
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.InitializeFailed">
            <summary>
            初始化失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.Initializing">
            <summary>
            初始化中
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.InitializeException">
            <summary>
            初始化异常
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleMetadata">
            <summary>
            存储模块的元数据信息
            ModuleFactory通过TypeID找到ModuleMetadata，然后动态创建模块实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleMetadata.ID">
            <summary>
            唯一标志符
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleMetadata.Name">
            <summary>
            模块的默认的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleMetadata.ClassName">
            <summary>
            模块的完整类型名
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.ReadOptions">
            <summary>
            指定对Excel里的空列的处理方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ReadOptions.IgnoreEmptyCell">
            <summary>
            忽略Excel里的空列
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ReadOptions.KeepEmptyCell">
            <summary>
            保留Excel里的空列（会保存一个空对象在ExcelRow里）
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.WriteOptions.CreateNew">
            <summary>
            创建一个新文件并写入
            如果源文件存在，那么覆盖源文件
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.WriteOptions.Append">
            <summary>
            向源文件追加新文件
            </summary>
        </member>
        <member name="T:DotNEToolkit.Utility.CSVSplitters">
            <summary>
            CSV文件的分隔符
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.CSVSplitters.Unkown">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.CSVSplitters.Comma">
            <summary>
            逗号分隔
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.CSVSplitters.Space">
            <summary>
            空格分隔
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.CSVSplitters.Tab">
            <summary>
            Tab键分隔
            </summary>
        </member>
        <member name="T:DotNEToolkit.Utility.CSVUtils">
            <summary>
            提供操作CSV格式文件的方法
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.CSVUtils.CSVSplitter">
            <summary>
            CSV文件一行的分隔符
            有的CSV文件是用逗号，有的是用空格分隔
            </summary>
        </member>
        <member name="M:DotNEToolkit.Utility.CSVUtils.TableData2CSVFile(DotNEToolkit.TableData,System.String,DotNEToolkit.Utility.CSVSplitters)">
            <summary>
            把TableData保存成一个CSV文件
            </summary>
            <param name="tableData"></param>
            <param name="csvPath"></param>
            <param name="splitter">CSV文件的分隔符</param>
        </member>
        <member name="M:DotNEToolkit.Utility.CSVUtils.CSV2TableData(System.String)">
            <summary>
            CSV格式的字符串转成DataTable
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.CSVUtils.CSVFile2TableData(System.String)">
            <summary>
            CSV文件转成DataTable
            </summary>
            <param name="csvFile"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.CSVUtils.CSVFile2Excel(System.String,System.String,DotNEToolkit.Excels.WriteOptions)">
            <summary>
            把CSV文件转换成Excel
            </summary>
            <param name="csvPath"></param>
            <param name="excelPath"></param>
            <param name="options">写入Excel文件的选项</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.CSVUtils.CSV2Excel(System.String,System.String,DotNEToolkit.Excels.WriteOptions)">
            <summary>
            把CSV文件内容转换成Excel
            </summary>
            <param name="csvText"></param>
            <param name="excelPath"></param>
            <param name="options">写入Excel文件的选项</param>
        </member>
        <member name="M:DotNEToolkit.Utility.CSVUtils.CSVFile2Objects``1(System.String,DotNEToolkit.Utility.CSVSplitters)">
            <summary>
            把一个CSV文件转换成一个对象集合
            要使用CSVColumnAttribute把类里的属性和CSV文件里的字段映射起来
            </summary>
            <typeparam name="T"></typeparam>
            <param name="csvPath"></param>
            <param name="splitter">CSV文件分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ImageUtils.FlipY(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RGB24图像左右翻转
            </summary>
            <param name="rgbBytes"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:DotNEToolkit.Utility.ImageUtils.FlipX(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RGB24图像上下翻转
            </summary>
            <param name="rgbBytes"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="T:DotNEToolkit.Utility.NumbericUtils">
            <summary>
            操作数字的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Utility.NumbericUtils.FixedDecimal(System.Double,System.Int32)">
            <summary>
            保留num位小数，会四舍五入
            </summary>
            <param name="src"></param>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.NumbericUtils.IsHexadecimal(System.Char)">
            <summary>
            判断一个字符是否是十六进制字符
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.NumbericUtils.AccumulateTo(System.Int32,System.Int32)">
            <summary>
            函数功能：
            如果value是437，ch是2，那么返回的结果就是4372
            
            从terminal项目拷贝
            </summary>
            <param name="value"></param>
            <param name="add"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.Utility.ExcelVersions.Xls">
            <summary>
            Excel 97 - 2003版本
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.ExcelVersions.Xlsx">
            <summary>
            Excel 2007版本
            </summary>
        </member>
        <member name="T:DotNEToolkit.Utility.ExcelUtils">
            <summary>
            封装Excel文件的导入，导出功能
            </summary>
        </member>
        <member name="M:DotNEToolkit.Utility.ExcelUtils.ExcelFile2TableData(System.String)">
            <summary>
            Excel文件转换成TableData
            </summary>
            <param name="excelPath">要转换的Excel文件的完整路径</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ExcelUtils.ExcelFile2CSVFile(System.String,System.String,DotNEToolkit.Utility.CSVSplitters)">
            <summary>
            Excel文件转换成CSV
            </summary>
            <param name="excelPath">要转换的Excel文件的完整路径</param>
            <param name="csvPath">要保存的CSV文件的完整路径</param>
        </member>
        <member name="M:DotNEToolkit.Utility.ExcelUtils.TableData2ExcelFile(System.String,DotNEToolkit.TableData,DotNEToolkit.Excels.WriteOptions,System.String,DotNEToolkit.Utility.ExcelVersions)">
            <summary>
            TableData转成Excel文件
            </summary>
            <param name="excelPath"></param>
            <param name="tableData"></param>
            <param name="options"></param>
            <param name="sheetName"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ExcelUtils.DataTable2ExcelFile(System.String,System.Data.DataTable,DotNEToolkit.Excels.WriteOptions,System.String,DotNEToolkit.Utility.ExcelVersions)">
            <summary>
            DataTable转成Excel文件
            </summary>
            <param name="excelPath"></param>
            <param name="table"></param>
            <param name="options"></param>
            <param name="sheetName"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ExcelUtils.Array2Excel(System.String,System.Object[0:,0:],DotNEToolkit.Excels.WriteOptions,System.String,DotNEToolkit.Utility.ExcelVersions)">
            <summary>
            把一个二维数组写到Excel里
            </summary>
            <param name="excelPath"></param>
            <param name="array">一维是行，二维是列</param>
            <param name="options"></param>
            <param name="sheetName"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ExcelUtils.ExcelFile2Objects``1(System.String)">
            <summary>
            Excel文件转Object列表
            </summary>
            <typeparam name="T"></typeparam>
            <param name="excelPath"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.Utility.HexNumberOptions.None">
            <summary>
            没有选项
            </summary>
        </member>
        <member name="F:DotNEToolkit.Utility.HexNumberOptions.WithPrefix">
            <summary>
            带有0x前缀
            </summary>
        </member>
        <member name="T:DotNEToolkit.Utility.ByteUtils">
            <summary>
            操作字节数组的帮助类
            </summary>
        </member>
        <member name="M:DotNEToolkit.Utility.ByteUtils.JoinHexNumber(System.Byte[],System.String,DotNEToolkit.Utility.HexNumberOptions)">
            <summary>
            把一个字节数组转成十六进制字符串
            不带0x前缀
            </summary>
            <param name="source"></param>
            <param name="separator">每个字节之间的分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ByteUtils.SplitBytes(System.String,System.String)">
            <summary>
            把一个十六进制的字符串分隔成byte数组
            </summary>
            <param name="hex">要分隔的字符串</param>
            <param name="separator">分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ByteUtils.Compare(System.Byte[],System.Byte[])">
            <summary>
            对两个字节数组进行比较操作
            </summary>
            <param name="array1">要比较的第一个字节数组</param>
            <param name="array2">要比较的第二个字节数组</param>
            <returns>每个字节是否相等</returns>
        </member>
        <member name="T:DotNEToolkit.Utility.NetworkUtils">
            <summary>
            提供网络相关的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Utility.NetworkUtils.GetBroadcastAddresses">
            <summary>
            获取所有网卡的IPv4广播地址
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.NetworkUtils.GetMACAddress">
            <summary>
            获取所有网卡的MAC地址
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotNEToolkit.Utility.PropertyAttribute`1.Property">
            <summary>
            该特性所对应的属性信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Utility.PropertyAttribute`1.Attribute">
            <summary>
            该属性所拥有的特性实例
            </summary>
        </member>
        <member name="T:DotNEToolkit.Utility.ReflectionUtils">
            <summary>
            反射工具函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Utility.ReflectionUtils.GetPropertyAttribute``1(System.Type)">
            <summary>
            获取某个类里的所有公开属性的某个特定类型的特性
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="classType">要获取的类的类型</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ReflectionUtils.GetPropertyAttribute``2">
            <summary>
            获取某个类里的所有公开属性的某个特定类型的特性
            </summary>
            <typeparam name="TAttribute">要获取的特性的类型</typeparam>
            <typeparam name="TClass"></typeparam>
            <returns>所有属性的特性集合</returns>
        </member>
        <member name="M:DotNEToolkit.Utility.ReflectionUtils.GetClassAttribute``2">
            <summary>
            获取某个类上的自定义特性
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TClass"></typeparam>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Expressions.AccessMember">
            <summary>
            存储要访问的成员信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.AccessMember.Name">
            <summary>
            要访问的成员名称
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.AccessMember.Type">
            <summary>
            成员类型
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.AccessMemberProperty">
            <summary>
            表示一个属性成员
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.ExpressionTypes">
            <summary>
            表达式类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionTypes.MacroDefinition">
            <summary>
            宏定义
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionTypes.StringConstant">
            <summary>
            字符串常量
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionTypes.Function">
            <summary>
            函数表达式
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.MemberTypes">
            <summary>
            表示成员类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.MemberTypes.Property">
            <summary>
            该成员是一个属性
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.IEvaluationContext">
            <summary>
            计算表达式需要的上下文信息
            该接口是一个标记接口，没有任何内容
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator">
            <summary>
            表达式求值程序
            当你需要实现一个表达式的时候，只要继承并实现这个类就可以了
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator.MinimalParameters">
            <summary>
            最少要多少个参数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator.Evaluate(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            计算表达式
            这个函数会对表达式进行一些计算前的校验操作，比如参数是不是合法..etc..
            真正计算表达式的逻辑在EvaluateCore函数里
            子类必须实现EvaluateCore函数
            </summary>
            <param name="expression"></param>
            <param name="context"></param>
            <returns>
            返回null则表示失败，否则成功
            </returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator.EvaluateCore(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            真正的计算表达式的逻辑
            子类必须实现该类
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Expressions.Expression">
            <summary>
            表达式树的子节点
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Parent">
            <summary>
            父节点
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Type">
            <summary>
            表达式类型
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Name">
            <summary>
            表达式名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Parameters">
            <summary>
            表达式参数列表
            也就是子表达式求值之后的结果
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Children">
            <summary>
            子表达式
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Value">
            <summary>
            表达式的值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.AccessMembers">
            <summary>
            存储要访问的成员信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.State">
            <summary>
            表达式状态
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.ExpressionParser">
            <summary>
            表达式解析器
            1. 把表达式字符串解析为一个树形结构
            2. 对树形结构进行求值计算
            
            在进行表达式求值的时候，会优先使用系统里预定义的表达式求值程序
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.userDefinedFile">
            <summary>
            用户定义的表达式配置文件路径
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.leftBracket">
            <summary>
            记录左括号的数量
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.rightBracket">
            <summary>
            记录右括号的数量
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.preDefinedEvas">
            <summary>
            缓存所有的表达式计算器
            </summary>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.#ctor(System.String)">
            <summary>
            ExpressionParser构造方法
            </summary>
            <param name="exprFile">要加载的表达式求值程序JSON配置文件，配置文件格式请参考Expressions/predefined.exp.json</param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsSpace(System.Char)">
            <summary>
            判断是否是空格，如果是空格那么忽略掉
            </summary>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamFunctionIndicator(System.Char)">
            <summary>
            是否是函数表达式字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamEntryIndicator(System.Char)">
            <summary>
            判断是否开始解析函数参数
            如果遇到了‘(’左括号，那么表示开始解析函数参数
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamStringValid(System.Char)">
            <summary>
            判断是否是有效的字符串参数
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamStringIndicator(System.Char)">
            <summary>
            判断是否是字符串参数
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamSplitter(System.Char)">
            <summary>
            判断是否是参数分隔符
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsAccessMemberEntryIndicator(System.Char)">
            <summary>
            判断是否是成员访问符
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamMemberValid(System.Char)">
            <summary>
            判断是否是有效的成员参数
            </summary>
            <param name="ch">要判断的字符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsAccessArrayIndicator(System.Char)">
            <summary>
            判断字符是否是访问数组成员
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsAccessFunctionIndicator(System.Char)">
            <summary>
            判断字符是否是访问函数成员
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EventGround(System.Char,DotNEToolkit.Expressions.Expression)">
            <summary>
            基态
            该函数处理以下几件事：
            1. 忽略空格键
            2. 判断是否是字符串参数，如果是则转到字符串参数状态
            3. 判断是否是函数参数，如果是则转到函数参数状态
            4. 判断是否是属性参数，如果是则转到属性参数状态
            5. 如果是参数分隔符则清空当前的参数
            </summary>
            <param name="ch"></param>
            <param name="parent"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EventParamFunction(System.Char,DotNEToolkit.Expressions.Expression)">
            <summary>
            处理函数状态
            </summary>
            <param name="ch"></param>
            <param name="parent"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EventParamTermination(System.Char,DotNEToolkit.Expressions.Expression)">
            <summary>
            处理ParamTermination状态下出现的字符
            字符串状态下出现了第二个单引号触发该状态
            
            该函数做以下几件事：
            1. 判断如果出现的左括号的次数等于右括号的次数，那么说明整个函数解析完了，跳转到基态
            2. 判断函数结束后面是否有成员访问符
            </summary>
            <param name="ch"></param>
            <param name="parent"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.BuildExpressionTree(System.String)">
            <summary>
            构造表达式树形列表
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.Evaluate(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            对表达式树进行求值
            从树形结构的儿子节点递归计算表达式的值，直到把根节点的值计算出来
            </summary>
            <param name="parent">要计算的表达式根节点</param>
            <param name="context">计算表达式的时候需要的额外数据</param>
            <returns>返回null则表示失败，否则成功</returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.TryGetEvaluator(System.String,System.Collections.Generic.List{DotNEToolkit.Expressions.ExpressionDefinition},System.Collections.Generic.Dictionary{System.String,DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator})">
            <summary>
            从指定的表达式定义列表和表达式求值程序池里查找一个表达式求值程序
            如果从表达式列表里找到了，那么反射实例化该表达式求值程序并把求值程序实例缓存到求值程序池里
            </summary>
            <param name="name">要查找的表达式的名字</param>
            <param name="exprDefines">表达式定义列表</param>
            <param name="evaluators">求值程序池</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.LoadDefinitions(System.String)">
            <summary>
            从给定的路径加载一个表达式定义列表
            </summary>
            <param name="exprFile">要加载的表达式定义文件路径</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.GetEvaluator(System.String)">
            <summary>
            根据表达式名字获取表达式求值程序的实例
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EvaluateExpression(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            计算指定表达式的值
            </summary>
            <param name="expression"></param>
            <param name="code">
            表达式计算的返回值，0表示成功，非0表示失败，失败的错误码由调用者定义
            </param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.InvokeAccessPropertyMember(System.String,System.Object)">
            <summary>
            访问某个对象的属性，返回属性值
            </summary>
            <param name="amp"></param>
            <param name="source">要访问的对象</param>
            <returns>
            返回null则表示失败，否则成功
            </returns>
        </member>
        <member name="T:DotNEToolkit.Expressions.ExpressionDefinition">
            <summary>
            表达式求值程序定义
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.ExpressionDefinition.Syntax">
            <summary>
            表达式语法
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.ExpressionDefinition.MinimalParameters">
            <summary>
            表达式最少要拥有多少个参数才能计算
            如果在计算的时候小于这个值，那么就返回计算失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionState.HasEvaluation">
            <summary>
            已经求过值了
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionState.WaitEvaluation">
            <summary>
            等待求值
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.Ground">
            <summary>
            初始状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.ParamFunction">
            <summary>
            当前状态是函数参数状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.ParamString">
            <summary>
            当前是字符串类型的参数
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.ParamTermination">
            <summary>
            字符串参数结束状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.AccessMemberEntry">
            <summary>
            成员访问状态入口，当出现了'.'符号的时候就会进入这个状态
            对象的成员有如下机种状态：
            1. 属性，以逗号结尾
            2. 函数，以左括号开头，右括号结尾
            3. 数组，以左中括号开头，右中括号结尾
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.GrammarError">
            <summary>
            语法错误状态
            </summary>
        </member>
        <member name="T:DotNEToolkit.AppManifest">
            <summary>
            App清单文件
            清单文件里只存储不可变的数据
            可变数据属于配置数据，调用ModularApp的GetConfig个SetConfig接口进行读写
            </summary>
        </member>
        <member name="P:DotNEToolkit.AppManifest.AsynchronousInitialization">
            <summary>
            是否异步初始化模块
            默认不异步，默认用同步初始化
            </summary>
        </member>
        <member name="P:DotNEToolkit.AppManifest.ModuleList">
            <summary>
            配置文件里的所有的模块列表
            </summary>
        </member>
        <member name="P:DotNEToolkit.AppManifest.SettingPath">
            <summary>
            App的配置文件路径
            </summary>
        </member>
        <member name="M:DotNEToolkit.AppManifest.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="T:DotNEToolkit.ModularApp`2">
            <summary>
            封装一个基于模块化（ModuleFactory）实现的App开发框架
            1. 实现了AppModule的依赖注入功能
            </summary>
            <typeparam name="TApp"></typeparam>
            <typeparam name="TManifest"></typeparam>
        </member>
        <member name="P:DotNEToolkit.ModularApp`2.Factory">
            <summary>
            模块工厂
            </summary>
        </member>
        <member name="P:DotNEToolkit.ModularApp`2.Manifest">
            <summary>
            App的配置文件
            </summary>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.Initialize">
            <summary>
            初始化App
            自动读取App.config文件里的appConfig里配置的配置文件路径
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.Initialize(System.String)">
            <summary>
            指定一个配置文件的路径初始化App
            </summary>
            <param name="configFile">App配置文件路径</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.Initialize(System.String,`1)">
            <summary>
            使用AppManifest的实例初始化App
            </summary>
            <param name="configFile">指定配置文件的完整路径，当调用SaveManifest的时候，将会使用该路径进行保存</param>
            <param name="manifest">要初始化的App清单</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.Release">
            <summary>
            释放App占用的资源
            </summary>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.SaveManifest">
            <summary>
            保存Manifest文件
            </summary>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.WriteSetting``1(System.String,``0)">
            <summary>
            写入并保存配置文件
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.ReadSetting``1(System.String,``0)">
            <summary>
            读取配置文件里的配置
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.OnInitialize">
            <summary>
            子类初始化
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.OnRelease">
            <summary>
            子类释放资源
            </summary>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.OnModuleStatusEvent(DotNEToolkit.Modular.IModuleInstance,DotNEToolkit.Modular.ModuleStatus)">
            <summary>
            处理模块状态改变事件
            </summary>
            <param name="moduleInst"></param>
            <param name="status">模块状态</param>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.OnModuleInitialized">
            <summary>
            处理所有模块都初始化成功的事件
            </summary>
        </member>
        <member name="M:DotNEToolkit.ModularApp`2.OnCircularReference(DotNEToolkit.Modular.IModuleInstance)">
            <summary>
            当出现模块循环引用的时候触发
            </summary>
            <param name="moduleInst">存在循环引用的模块</param>
        </member>
        <member name="T:DotNEToolkit.Packaging.BINFilePackage">
            <summary>
            把所有的数据打包成一个文件
            并生成一个索引文件用来保存每个小文件的描述信息
            
            Index文件格式：
            |-------------|
            | header size |   -> 4字节
            |-------------|
            |  file name  |   -> \0结尾, UTF8编码
            |-------------|
            
            
            目录项格式：
            |-------------|
            |   offset    |   -> 8字节
            |-------------|
            |  file name  |   -> \0结尾, UTF8编码
            |-------------|
            
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.BINFilePackage.Capacity">
            <summary>
            文件的总大小字节数
            会预先在磁盘里分配Capacity大小的文件
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.BINFilePackage.IndexPath">
            <summary>
            索引文件的路径
            </summary>
        </member>
        <member name="M:DotNEToolkit.Packaging.BINFilePackage.CreateIndexFile">
            <summary>
            创建一个新的索引文件
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Packaging.FileItem">
            <summary>
            存储一个要打包的文件信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.FileItem.Name">
            <summary>
            文件名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.FileItem.PathRelativePackage">
            <summary>
            在压缩包内的完整路径
            包含文件名
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.FileItem.Content">
            <summary>
            文件内容
            使用Size字段指定内容的长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.FileItem.Size">
            <summary>
            文件的真实长度
            注意该值可以不等于Content的长度
            写入Size个字节的数据
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.FileItem.Offset">
            <summary>
            文件在Content里的偏移量
            </summary>
        </member>
        <member name="T:DotNEToolkit.Packaging.DirectoryItem">
            <summary>
            存储一个要打包的目录信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.DirectoryItem.BackslashPath">
            <summary>
            带有反斜杠的路径
            SharpZipLib会把带有反斜杠结束的路径当成压缩包里的一个目录来处理
            所以在把目录写入压缩包的时候路径要带反斜杠
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.DirectoryItem.Path">
            <summary>
            目录名字
            压缩包里的完整路径
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.DirectoryItem.FileList">
            <summary>
            该目录下的所有文件
            </summary>
        </member>
        <member name="M:DotNEToolkit.Packaging.DirectoryItem.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Packaging.DirectoryItem.Size">
            <summary>
            计算目录的总大小
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Packaging.FilePackage">
            <summary>
            将文件流或者目录打包成一个文件（包括但不限于压缩文件）保存
            支持流式打包
            </summary>
        </member>
        <member name="F:DotNEToolkit.Packaging.FilePackage.packagePath">
            <summary>
            最终的压缩包的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.FilePackage.Type">
            <summary>
            打包文件的类型
            </summary>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.Create(System.String,DotNEToolkit.Packaging.FilePackages)">
            <summary>
            使用一个空流创建一个压缩包
            </summary>
            <param name="packagePath">压缩包的路径，如果没有这个压缩包文件，则会创建一个</param>
            <param name="package"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.Open">
            <summary>
            创建一个空的压缩包
            </summary>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.Close">
            <summary>
            关闭并保存打包文件
            </summary>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.PackDirectory(System.Collections.Generic.List{DotNEToolkit.Packaging.DirectoryItem})">
            <summary>
            往一个已经存在的打包文件里追加目录列表
            </summary>
            <param name="dirList">要追加到打包文件里的目录列表</param>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.PackFile(System.Collections.Generic.List{DotNEToolkit.Packaging.FileItem})">
            <summary>
            往压缩包里打包文件
            </summary>
            <param name="fileList"></param>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.PackDirectory(System.String)">
            <summary>
            打包一个目录
            </summary>
            <param name="baseDir">要打包的目录</param>
        </member>
        <member name="M:DotNEToolkit.Packaging.FilePackage.CreateFile(System.IO.MemoryStream,System.String)">
            <summary>
            把一个内存流写到一个文件里
            </summary>
            <param name="ms"></param>
            <param name="filePath"></param>
        </member>
        <member name="T:DotNEToolkit.Packaging.FilePackages">
            <summary>
            定义可以打包的文件类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Packaging.FilePackages.Zip">
            <summary>
            Zip压缩包格式的打包
            后缀名.zip
            </summary>
        </member>
        <member name="F:DotNEToolkit.Packaging.FilePackages.TarArchive">
            <summary>
            tar包
            </summary>
        </member>
        <member name="F:DotNEToolkit.Packaging.FilePackages.Binary">
            <summary>
            把所有的数据打包成一个文件
            </summary>
        </member>
        <member name="T:DotNEToolkit.Packaging.TARFilePackage">
            <summary>
            https://www.moon-soft.com/program/FORMAT/comm/tar.htm
            https://blog.csdn.net/qq_20553613/article/details/109892160#:~:text=2.2%20tar%E6%96%87%E4%BB%B6%E7%89%B9%E7%82%B9%201,%E4%BB%A5512%E5%AD%97%E8%8A%82%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95%E5%9D%97%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E8%B6%B3%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95%E5%9D%97%E7%9A%84%E4%BB%A50%E5%A1%AB%E5%85%85%202%20%E4%BB%A5%E2%80%9C%E6%96%87%E4%BB%B6%E5%A4%B4%2B%E6%9C%89%E6%95%88%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E2%80%9D%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A8
            一个空文件打包后为512*3字节，包括一个tar结构头，一个全零的block存储文件内容，一个全零的tar结构
            </summary>
        </member>
        <member name="F:DotNEToolkit.Packaging.TARFilePackage.DefaultWriteBufferSize">
            <summary>
            默认的每次写入tar包的大小
            默认是2M
            这个值越大，磁盘的写入速度越高
            </summary>
        </member>
        <member name="P:DotNEToolkit.Packaging.TARFilePackage.WriteBufferSize">
            <summary>
            每次写入文件的大小
            单位字节
            </summary>
        </member>
        <member name="T:DotNEToolkit.Packaging.ZIPFilePackage">
            <summary>
            使用SharpZipLib库实现的文件打包器
            </summary>
        </member>
        <member name="T:DotNEToolkit.ImageCodec">
            <summary>
            一个图像编/解码器
            </summary>
        </member>
        <member name="F:DotNEToolkit.ImageCodec.BMPCodec">
            <summary>
            BMP文件格式编解码器
            </summary>
        </member>
        <member name="F:DotNEToolkit.ImageCodec.Codecs.BMP">
            <summary>
            BMP格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.ImageCodec.Codecs.PNG">
            <summary>
            PNG压缩格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.ImageCodec.Codecs.JPEG">
            <summary>
            JPEG压缩格式
            </summary>
        </member>
        <member name="T:DotNEToolkit.ImageCodec.PixelFormats">
            <summary>
            定义图片的像素格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.ImageCodec.PixelFormats.Gray8">
            <summary>
            单色，8位索引图
            图像数据指向调色板的索引序号
            </summary>
        </member>
        <member name="P:DotNEToolkit.ImageCodec.Type">
            <summary>
            编码器所支持的格式
            </summary>
        </member>
        <member name="M:DotNEToolkit.ImageCodec.Encode(System.Byte[],System.Byte[],System.Int32,System.Int32,DotNEToolkit.ImageCodec.PixelFormats)">
            <summary>
            对一段图像原始数据进行编码
            </summary>
            <param name="buffer">
            要编码到的内存缓冲区
            注意：外部要开批足够的缓冲区，Encode内部不检查缓冲区的长度
            </param>
            <param name="rawData">图像原始数据</param>
            <param name="width">图像宽度</param>
            <param name="height">图像高度</param>
            <param name="rawFormat">原始数据的像素格式</param>
            <returns>返回大于0表示编码后的图片文件的大小，小于0表示错误码</returns>
        </member>
        <member name="F:DotNEToolkit.BMPImageCodec.Gray8ColorPlate">
            <summary>
            8位索引图使用的调色板信息
            </summary>
        </member>
        <member name="M:DotNEToolkit.BMPImageCodec.GetBitsPerPixel(DotNEToolkit.ImageCodec.PixelFormats)">
            <summary>
            获取某种格式里每个像素的位数
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.BMPImageCodec.GetColorPlate(DotNEToolkit.ImageCodec.PixelFormats)">
            <summary>
            获取某个格式使用的调色板信息
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Log4net">
            <summary>
            提供Log4Net的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Log4net.InitializeLog4net(System.String)">
            <summary>
            初始化Log4net库
            默认使用程序根目录下的log4net.xml配置文件初始化log4net
            </summary>
        </member>
        <member name="T:DotNEToolkit.MySQLInstaller">
            <summary>
            封装Windows下绿色版mysql的安装程序逻辑
            把这个程序放到Mysql/bin目录下，然后运行
            </summary>
        </member>
        <member name="F:DotNEToolkit.MySQLInstaller.DefualtMysqlConfig">
            <summary>
            默认的Mysql配置文件内容
            </summary>
        </member>
        <member name="E:DotNEToolkit.MySQLInstaller.Progress">
            <summary>
            安装进度回调
            </summary>
        </member>
        <member name="M:DotNEToolkit.MySQLInstaller.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="mysqlDir">mysql的基目录</param>
        </member>
        <member name="M:DotNEToolkit.MySQLInstaller.Install">
            <summary>
            把Mysql安装成一个Windows服务
            </summary>
        </member>
        <member name="M:DotNEToolkit.MySQLInstaller.Uninstall">
            <summary>
            卸载Mysql Windows服务
            </summary>
        </member>
        <member name="T:DotNEToolkit.Objects">
            <summary>
            Object类型的扩展
            </summary>
        </member>
        <member name="M:DotNEToolkit.Objects.Copy``1(``0)">
            <summary>
            复制一个一模一样的对象
            如果被复制的对象里有引用类型，那么也会重新创建一个新的对象引用
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="E:DotNEToolkit.ProcessComm.ProcessCommClient.StatusChanged">
            <summary>
            进程间通信对象的状态改变的时候触发
            </summary>
        </member>
        <member name="P:DotNEToolkit.ProcessComm.ProcessCommClient.Status">
            <summary>
            客户端的当前状态
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Initialize(System.String)">
            <summary>
            初始化IPC
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Release">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Connect(System.String)">
            <summary>
            连接IPC进程
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Disconnect">
            <summary>
            与IPC进程断开连接
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.CommStates">
            <summary>
            定义通信客户端的状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.CommStates.ConnectFailed">
            <summary>
            连接失败
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.ProcessCommObject">
            <summary>
            提供进程间通信对象的通用接口
            </summary>
        </member>
        <member name="E:DotNEToolkit.ProcessComm.ProcessCommObject.DataReceived">
            <summary>
            当收到客户端发送过来的命令的时候触发
            int：命令类型
            object：命令参数，可能是byte数组，可能是string，也可能是一个对象
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommObject.Send(System.Int32,System.Object)">
            <summary>
            向进程发送一个对象
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommObject.Send(System.Int32,System.String)">
            <summary>
            发送一条命令
            </summary>
            <param name="cmdType">命令类型</param>
            <param name="cmdParams">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommObject.Send(System.Int32,System.Byte[])">
            <summary>
            发送一条命令
            </summary>
            <param name="cmdType">命令类型</param>
            <param name="cmdParams">字节数组类型的命令参数</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.ProcessCommTypes">
            <summary>
            定义进程间通信的方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.ProcessCommTypes.WCFNamedPipe">
            <summary>
            WCF NetNamedPipe绑定
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.ProcessCommTypes.SharedMemory">
            <summary>
            使用共享内存实现的IPC通信
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.ProcessCommTypes.TCP">
            <summary>
            使用TCP实现的IPC通信
            </summary>
        </member>
        <member name="T:DotNEToolkit.StringTerminator">
            <summary>
            指定StringEnumerator使用的换行符
            </summary>
        </member>
        <member name="F:DotNEToolkit.StringTerminator.CR">
            <summary>
            StringEnumerator会把换行符转换成CR
            </summary>
        </member>
        <member name="F:DotNEToolkit.StringTerminator.LF">
            <summary>
            StringEnumerator会把换行符转换成LF
            </summary>
        </member>
        <member name="T:DotNEToolkit.StringEnumerator">
            <summary>
            实现一个增强版的CharEnumerator
            1. 该Enumerator提供了Peek的功能
            2. 提供了MoveUntil函数
            3. 提供了CharPosition属性标识当前字符的位置
            </summary>
        </member>
        <member name="F:DotNEToolkit.StringEnumerator.peeks">
            <summary>
            peek的次数
            每次调用MoveNext的时候peeks会清零
            </summary>
        </member>
        <member name="P:DotNEToolkit.StringEnumerator.CharPosition">
            <summary>
            获取当前字符的位置
            </summary>
        </member>
        <member name="P:DotNEToolkit.StringEnumerator.Current">
            <summary>
            当前的字符
            </summary>
        </member>
        <member name="P:DotNEToolkit.StringEnumerator.Peeked">
            <summary>
            当前Peek的字符
            </summary>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext">
            <summary>
            向前Move一个字符
            每次Move都会重置Peek指针
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext(System.Int32)">
            <summary>
            向前move step个字符
            </summary>
            <param name="step"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext(System.Char)">
            <summary>
            向前move，遇到ignore字符直接忽略并继续move
            </summary>
            <param name="ignore">要忽略的字符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext(System.Char,System.String@)">
            <summary>
            向前Move，直到Move到until为止
            每次Move都会重置Peek指针
            </summary>
            <param name="until">要move到的字符</param>
            <param name="moved">保存move到的字符串，不包含until</param>
            <returns>
            如果Move到了until，那么返回true，否则返回false
            </returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.Peek">
            <summary>
            向前peek，会移动Peek指针
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.Reset">
            <summary>
            重置指针状态
            </summary>
        </member>
        <member name="T:DotNEToolkit.MarshalUtils">
            <summary>
            提供PInvoke的公共函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.MarshalUtils.CreateStructurePointer(System.Object)">
            <summary>
            结构体转byte数组
            注意，该函数会从非托管空间开辟内存
            在指针不用的时候需要调用FreeStructurePtr释放内存
            </summary>
            <param name="structObj">要转换的结构体</param>
            <returns>指向结构体的指针</returns>
        </member>
        <member name="M:DotNEToolkit.MarshalUtils.FreeStructurePointer(System.IntPtr)">
            <summary>
            释放用StructureToPtr函数分配的结构体指针
            </summary>
            <param name="structPtr">要释放的指针</param>
        </member>
        <member name="M:DotNEToolkit.MarshalUtils.Bytes2Struct``1(System.Byte[])">
            <summary>
            byte数组转struct
            相当于C语言里的指针强转结构体
            </summary>
            <typeparam name="T"></typeparam>
            <param name="bytes">要转换的byte数组</param>
            <param name="structInstance">要存放结构体数据的结构体实例</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Bindings.BindableBase">
            <summary>
            表示一个属性可绑定的对象
            可依赖注入的对象
            
            可以让普通的对象像WPF里的DependecyObject一样，对DependencyObject的属性进行绑定（WPF是在XAML里绑定）。
            这样就不用每次都对属性赋值了，可以更专注于每个类的业务逻辑的开发，没有了很多属性的赋值操作，代码可读性也更强，同时也弱化了类与类之间的耦合性
            </summary>
        </member>
        <member name="P:DotNEToolkit.Bindings.BindablePropertyAttribute.DefaultValue">
            <summary>
            成员的默认值
            </summary>
        </member>
        <member name="T:DotNEToolkit.BufferQueue`1">
            <summary>
            Queue
            用于生产者消费者的缓冲池。和传统模式不同的是，当待处理队列已满时，策略是丢弃某个对象而不是让生产者等待
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DotNEToolkit.BufferQueue`1.MaxPoolSize">
            <summary>
            缓冲池最大允许长度，0 表示没有最大长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.BufferQueue`1.Size">
            <summary>
            获取队列里元素的数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.BufferQueue`1.Enqueue(`0)">
            <summary>
            将缓冲对象进入缓冲池
            </summary>
            <param name="t"></param>
            <returns>0 没有任何遗弃，1 缓冲池已满，遗弃一个对象</returns>
        </member>
        <member name="M:DotNEToolkit.BufferQueue`1.Dequeue">
            <summary>
            取出一个缓冲对象.如果池中已空，将会挂起线程等待
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.ConfigFactory`1">
            <summary>
            根据配置文件生成相应的实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.ConfigFactory`1.ConfigKey">
            <summary>
            Factory 读取AppSetting配置所用的key
            </summary>
        </member>
        <member name="M:DotNEToolkit.ConfigFactory`1.CreateInstance">
            <summary>
            创建一个接口对象T的实例
            </summary>
            <typeparam name="T">需要实现的接口</typeparam>
            <returns></returns>
            <remarks>
            该函数将自动读取配置文件，并根据配置文件里AppSetting中ConfigKey所对应的值自动选择合适的实现。
            ConfigKey所对应的键值为所需接口T的完整类名。如果需要指定assembly名, 则在类名后用逗号隔开
            例如："ICare.EventSender.DirectSender, EventSender"
            </remarks>
        </member>
        <member name="M:DotNEToolkit.ConfigFactory`1.CreateInstance(System.String,System.String)">
            <summary>
            根据类名和Assebmly名创建IEventDispatcher
            </summary>
            <param name="className"></param>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ConfigFactory`1.CreateInstance(System.String,System.Object[])">
            <summary>
            根据指定类名创建IEventDispatcher
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.AccessBase.GetModels``1(DotNEToolkit.DataAccess.DBManager,System.String,System.Data.CommandType,System.Object[])">
            <summary>
            Sql参数必须以@0, @1，@2等方式写出，args次序需和sql中的一致
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dbManager"></param>
            <param name="sql"></param>
            <param name="commandType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.AccessBase.GetModel``1(DotNEToolkit.DataAccess.DBManager,System.String,System.Data.CommandType,System.Object[])">
            <summary>
            Sql参数必须以@0, @1，@2等方式写出，args次序需和sql中的一致
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dbManager"></param>
            <param name="sql"></param>
            <param name="commandType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.sqlServerCeProviderInst">
            <summary>
            SqlServerCe Provider缓存实例
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.oracleProviderInst">
            <summary>
            Oracle Provider缓存实例
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.mysqlProviderInst">
            <summary>
            MySql Provider缓存实例
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.sqliteProviderInst">
            <summary>
            Sqlite Provider缓存实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataAccess.DBField.IsAutoIncrement">
            <summary>
            是否为自增列
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataAccess.DBField.IsKey">
            <summary>
            是否为主键
            </summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.AttachParameters(System.Data.Common.DbCommand,System.Data.Common.DbParameter[])">
            <summary>
            This method is used to attach array of DbParameters to a DbCommand.
            
            This method will assign a value of DbNull to any parameter with a direction of
            InputOutput and a value of null.  
            
            This behavior will prevent default values from being used, but
            this will be the less common case than an intended pure output parameter (derived as InputOutput)
            where the user provided no input value.
            </summary>
            <param name="command">The command to which the parameters will be added</param>
            <param name="commandParameters">An array of DbParameters to be added to command</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.AssignParameterValues(System.Data.Common.DbParameter[],System.Data.DataRow)">
            <summary>
            This method assigns dataRow column values to an array of DbParameters
            </summary>
            <param name="commandParameters">Array of DbParameters to be assigned values</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.AssignParameterValues(System.Data.Common.DbParameter[],System.Object[])">
            <summary>
            This method assigns an array of values to an array of DbParameters
            </summary>
            <param name="commandParameters">Array of DbParameters to be assigned values</param>
            <param name="parameterValues">Array of objects holding the values to be assigned</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.PrepareCommand(System.Data.Common.DbCommand,System.Data.Common.DbConnection,System.Data.Common.DbTransaction,System.Data.CommandType,System.String,System.Data.Common.DbParameter[],System.Boolean@)">
            <summary>
            This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
            to the provided command
            </summary>
            <param name="command">The DbCommand to be prepared</param>
            <param name="connection">A valid DbConnection, on which to execute this command</param>
            <param name="transaction">A valid DbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <param name="commandParameters">An array of DbParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="mustCloseConnection"><c>true</c> if the connection was opened by the method, otherwose is false.</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.CreateCommand(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.String[])">
            <summary>
            Simplify the creation of a Db command object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <remarks>
            e.g.:  
             DbCommand command = CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
            </remarks>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
            <returns>A valid DbCommand object</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns no resultset and takes no parameters) against the database specified in 
            the connection string
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns no resultset) against the database specified in the connection string 
            using the provided parameters
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns no resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(connString, "PublishOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored prcedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns no resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns no resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns no resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(conn, "PublishOrders", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns no resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns no resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns no resultset) against the specified 
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(conn, trans, "PublishOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(connString, "GetOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(conn, "GetOrders", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified 
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(trans, "GetOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="T:DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership">
            <summary>
            This enum is used to indicate whether the connection was provided by the caller, or created by DbHelper, so that
            we can set the appropriate CommandBehavior when calling ExecuteReader()
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership.Internal">
            <summary>Connection is owned and managed by DbHelper</summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership.External">
            <summary>Connection is owned and managed by the caller</summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.Common.DbTransaction,System.Data.CommandType,System.String,System.Data.Common.DbParameter[],DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership)">
            <summary>
            Create and prepare a DbCommand, and call ExecuteReader with the appropriate CommandBehavior.
            </summary>
            <remarks>
            If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
            
            If the caller provided the connection, we want to leave it to them to manage.
            </remarks>
            <param name="connection">A valid DbConnection, on which to execute this command</param>
            <param name="transaction">A valid DbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="connectionOwnership">Indicates whether the connection parameter was provided by the caller, or created by DbHelper</param>
            <returns>DbDataReader containing the results of the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DbDataReader dr = ExecuteReader(connString, "GetOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Db command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DbDataReader dr = ExecuteReader(conn, "GetOrders", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
              DbDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DbDataReader dr = ExecuteReader(trans, "GetOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, "GetOrderCount", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a 1x1 resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, "GetOrderCount", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a 1x1 resultset) against the specified
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, "GetOrderCount", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="T:DotNEToolkit.DataAccess.DbHelperParameterCache">
            <summary>
            DbHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
            ability to discover parameters for stored procedures at run-time.
            </summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.DiscoverSpParameterSet(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Resolve at run time the appropriate set of DbParameters for a stored procedure
            </summary>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">Whether or not to include their return value parameter</param>
            <returns>The parameter array discovered.</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.CloneParameters(System.Data.Common.DbParameter[])">
            <summary>
            Deep copy of cached DbParameter array
            </summary>
            <param name="originalParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.CacheParameterSet(System.String,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters to be cached</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetCachedParameterSet(System.String,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An array of DbParamters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.String,DotNEToolkit.DataAccess.ProviderType,System.String)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.String,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSetInternal(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="P:DotNEToolkit.DataAccess.DBManager.CommandTimeout">
            <summary>
            命令执行的缺省超时时间
            </summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DBManager.FillDbParameters(System.Object[])">
            <summary>
            产生以@0, @1, @2...的一组DB变量
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DirectoryExtentions">
            <summary>
            对目录的扩展类
            </summary>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.EnumerateDirectories(System.String)">
            <summary>
            枚举某个目录，会把异常截住
            </summary>
            <param name="dir">要枚举的目录</param>
            <returns>子目录列表</returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.EnumerateFiles(System.String)">
            <summary>
            枚举某个目录下的所有文件，会把异常截住
            如果某个目录没有访问权限，.NET自带的枚举函数会抛异常
            </summary>
            <param name="dir">要枚举的目录</param>
            <returns>文件列表</returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.DirectorySize(System.String)">
            <summary>
            获取目录大小
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.DirectoryReadableSize(System.String)">
            <summary>
            以易于阅读的格式输出文件大小（例如 1K 234M 2G等）
            </summary>
            <param name="size">以字节为单位的大小</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.DirectoryReadableSize(System.Int64)">
            <summary>
            以易于阅读的格式输出文件大小（例如 1K 234M 2G等）
            </summary>
            <param name="size">以字节为单位的大小</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.CopyDirectory(System.String,System.String)">
            <summary>
            拷贝目录及目录下的子目录和文件
            </summary>
            <param name="sourceDir">要拷贝的目录</param>
            <param name="destDir">拷贝到的目标目录</param>
        </member>
        <member name="T:DotNEToolkit.Extentions.EnumMember">
            <summary>
            描述一个枚举成员
            </summary>
        </member>
        <member name="P:DotNEToolkit.Extentions.EnumMember.Name">
            <summary>
            枚举的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Extentions.EnumMember.Value">
            <summary>
            枚举的值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Extentions.EnumMember.Description">
            <summary>
            枚举的描述信息
            使用Attribute指定
            </summary>
        </member>
        <member name="M:DotNEToolkit.Extentions.Enumerations.GetMemberList``1">
            <summary>
            把一个枚举类型转换成实体集合
            </summary>
            <typeparam name="T">要转换的枚举类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Extentions.Enumerations.ParseDescription(System.Reflection.FieldInfo)">
            <summary>
            解析枚举字段上的DescriptionAttribute特性
            </summary>
            <param name="enumField"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.StreamUtils">
            <summary>
            封装对流的一些操作
            </summary>
        </member>
        <member name="M:DotNEToolkit.StreamUtils.ReadFull(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            从流中读取数据，一直读满size个字节为止
            </summary>
            <param name="stream"></param>
            <param name="bytes">存储读取道的数据的缓冲区</param>
            <param name="offset">要读取的数据偏移量</param>
            <param name="size">要读取的字节数，如果为0，那么读取bytes.Length个字节</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.SocketUtils">
            <summary>
            封装可以快速操作Socket的方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.SocketUtils.ReceiveFull(System.Net.Sockets.Socket,System.Byte[],System.Int32)">
            <summary>
            读取一段完整的数据
            注意当该函数返回false的时候，应该关闭Socket
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <param name="timeout">超时时间，如果读取数据的时候超过此时间还没读到，那么就返回false</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.SocketUtils.SendFull(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送一段完整的数据
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.SocketUtils.SendFull(System.Net.Sockets.Socket,System.Byte[],System.Int32)">
            <summary>
            发送一段完整的数据
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.HttpRequestHelper">
            <summary>
            提供发送HTTP请求的函数
            </summary>
        </member>
        <member name="T:DotNEToolkit.BlankCharacterOptions">
            <summary>
            指定如何处理INI文件里的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.None">
            <summary>
            遇到空白字符不做处理
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.Delete">
            <summary>
            删除两端的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.OnlyDeleteFirst">
            <summary>
            只删除开头的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.OnlyDeleteLast">
            <summary>
            只删除结尾的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.DeleteAll">
            <summary>
            删除所有空白字符
            </summary>
        </member>
        <member name="T:DotNEToolkit.INIReader">
            <summary>
            INI文件读写器
            </summary>
        </member>
        <member name="F:DotNEToolkit.INIReader.values">
            <summary>
            section -> values
            </summary>
        </member>
        <member name="T:DotNEToolkit.linux.tail">
            <summary>
            模拟linux的tail工具
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.sleep_period">
            <summary>
            如果打开文件失败，那么这个值指定重试打开文件的间隔时间
            打开文件成功后，这个值指定每次读取文件的间隔时间
            单位是毫秒
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.BUFSIZE">
            <summary>
            每次读取的缓冲区大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.NEW_LINE">
            <summary>
            默认的换行符
            </summary>
        </member>
        <member name="T:DotNEToolkit.linux.tail.tail_event_type">
            <summary>
            tail工具的事件
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_event_type.TAIL_EXIT">
            <summary>
            退出
            </summary>
        </member>
        <member name="T:DotNEToolkit.linux.tail.tail_options">
            <summary>
            tail选项
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_options.follow">
            <summary>
            same as 'tail -f'
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_options.readline">
            <summary>
            按行读取，换行符是\n
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_options.retry">
            <summary>
            如果文件不存在，是否一直重试读取文件
            </summary>
        </member>
        <member name="E:DotNEToolkit.linux.tail.callback">
            <summary>
            第一个参数是tail对象
            第二个参数是事件类型
            第三个参数是事件类型所关联的数据
            第四个参数是userData
            </summary>
        </member>
        <member name="P:DotNEToolkit.linux.tail.period">
            <summary>
            读取文件的间隔时间
            </summary>
        </member>
        <member name="P:DotNEToolkit.linux.tail.bufsize">
            <summary>
            每次读取文件的缓冲区大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.linux.tail.encoding">
            <summary>
            读取文件的时候的编码格式
            </summary>
        </member>
        <member name="M:DotNEToolkit.linux.tail.trim_line(System.Char[])">
            <summary>
            如果不是完整的一行数据，那么把不完整的数据截断并保存到remain里
            </summary>
            <param name="chars">返回不完整的行的数据</param>
        </member>
        <member name="M:DotNEToolkit.CollectionUtils.GetValue``1(System.Collections.IDictionary,System.Object,``0)">
            <summary>
            把字典里的数据转成对应类型的数据
            支持把枚举字符串和枚举值转换成枚举类型
            </summary>
            <typeparam name="T"></typeparam>
            <param name="settings"></param>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.CollectionUtils.GetValue``1(System.Collections.IDictionary,System.String)">
            <summary>
            如果不存在对应的Key，那么直接抛异常
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.CollectionUtils.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            把字符串数组中的所有元素放入一个字符串。
            </summary>
            <param name="list"></param>
            <param name="separator">指定要使用的分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.CollectionUtils.HasDuplicated(System.Collections.Generic.List{System.String})">
            <summary>
            判断一个集合里是否有重复元素
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Internals.Confguration">
            <summary>
            读取配置的类
            </summary>
        </member>
        <member name="T:DotNEToolkit.JSONHelper">
            <summary>
            JSON函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.ParseDirectory``1(System.String,System.String)">
            <summary>
            把一个目录里所有的符合pattern的文件序列化成一个List
            </summary>
            <typeparam name="T"></typeparam>
            <param name="searchDir"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.Parse``1(System.String,``0)">
            <summary>
            把一个JSON字符串转换成一个JSON对象
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="json"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.ParseFile``1(System.String)">
            <summary>
            把一个json文件序列化成C#对象
            该函数不会对异常做处理，异常由调用者截获并处理
            如果该函数对异常做处理，那么调用者可能不知道出现异常的详细原因
            </summary>
            <typeparam name="TResult">要序列化成的对象类型</typeparam>
            <param name="filePath">要序列化的json文件的路径</param>
            <returns>如果序列化失败，那么返回空</returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.ParseFile``1(System.String,``0)">
            <summary>
            把一个文件序列化成JSON对象
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="filePath"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.File2Object``1(System.String,``0)">
            <summary>
            把一个文件序列化成JSON对象
            如果解析失败, 不会抛异常, 会返回defaultObject
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="filePath"></param>
            <param name="defaultObject"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.File2Object``1(System.String)">
            <summary>
            把一个json文件序列化成C#对象
            该函数不会对异常做处理，异常由调用者截获并处理
            如果该函数对异常做处理，那么调用者可能不知道出现异常的详细原因
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.Object2File``1(System.String,``0)">
            <summary>
            把一个C#对象序列化成JSON格式并写入到一个文件里
            该函数不会返回错误码，由调用者去截取异常并处理
            </summary>
            <typeparam name="TObject">要写入的对象类型</typeparam>
            <param name="filePath">要保存的文件路径</param>
            <param name="obj">要写入的对象实例</param>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.CloneObject``2(``0)">
            <summary>
            克隆一个对象
            先把inputObject转换成JSON字符串，再把JSON字符串转成TOutput类型的对象
            </summary>
            <typeparam name="TInput"></typeparam>
            <typeparam name="TOutput"></typeparam>
            <param name="inputObject"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.JSONDatabase">
            <summary>
            把一个json文件当成数据库去用
            </summary>
        </member>
        <member name="M:DotNEToolkit.JSONDatabase.Insert``1(System.String,``0)">
            <summary>
            向一个集合里插入一条数据
            </summary>
            <typeparam name="T">集合里的类型</typeparam>
            <param name="jsonFile">json文件路径</param>
            <param name="item">要插入的元素的实例</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONDatabase.SaveAll``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            保存所有对象，会覆盖JSON文件
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="jsonFile"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DesktopArea">
            <summary>
            表示一个鼠标区域
            </summary>
        </member>
        <member name="P:DotNEToolkit.DesktopArea.ID">
            <summary>
            桌面区域的唯一标志符
            </summary>
        </member>
        <member name="P:DotNEToolkit.DesktopArea.Area">
            <summary>
            桌面区域
            </summary>
        </member>
        <member name="E:DotNEToolkit.MouseScanner.MouseEnter">
            <summary>
            当鼠标移动到指定区域的时候触发
            </summary>
        </member>
        <member name="T:DotNEToolkit.ObjectCast">
             <summary>
             属性转换类，将一个类的属性值转换给另外一个类的同名属性，注意该类使用的是浅表复制。
             <example>
                    下面几种用法一样:
                    ModuleCast.GetCast(typeof(CarInfo), typeof(ImplCarInfo)).Cast(info, ic);
                    ModuleCast.CastObject《CarInfo, ImplCarInfo》(info, ic);
                    ModuleCast.CastObject(info, ic);
            
                    ImplCarInfo icResult= info.CopyTo《ImplCarInfo》(null);
            
                    ImplCarInfo icResult2 = new ImplCarInfo();
                    info.CopyTo《ImplCarInfo》(icResult2);
             
             </example>
             </summary>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.GetCast(System.Type,System.Type)">
            <summary>
            获取要转换的当前转换类实例
            </summary>
            <param name="sourceType">要转换的源类型</param>
            <param name="targetType">目标类型</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.#ctor(System.Type,System.Type)">
            <summary>
            以两个要转换的类型作为构造函数，构造一个对应的转换类
            </summary>
            <param name="sourceType"></param>
            <param name="targetType"></param>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.Cast(System.Object,System.Object)">
            <summary>
            将源类型的属性值转换给目标类型同名的属性
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.Cast(System.Object,System.Object,System.String[])">
            <summary>
            将源类型的属性值转换给目标类型同名的属性，排除要过滤的属性名称
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.CastObject``2(``0,``1)">
            <summary>
            转换对象
            </summary>
            <typeparam name="TSource">源类型</typeparam>
            <typeparam name="TTarget">目标类型</typeparam>
            <param name="source">源对象</param>
            <param name="target">目标对象</param>
        </member>
        <member name="T:DotNEToolkit.ObjectCast.CastProperty">
            <summary>
            转换属性对象
            </summary>
        </member>
        <member name="T:DotNEToolkit.ObjectCast.PropertyAccessorHandler">
            <summary>
            属性访问器
            </summary>
        </member>
        <member name="T:DotNEToolkit.ObjectCastExtension">
            <summary>
            对象转换扩展
            </summary>
        </member>
        <member name="M:DotNEToolkit.ObjectCastExtension.CopyTo``1(System.Object,``0,System.String[])">
            <summary>
            将当前对象的属性值复制到目标对象，使用浅表复制
            </summary>
            <typeparam name="T">目标对象类型</typeparam>
            <param name="source">源对象</param>
            <param name="target">目标对象，如果为空，将生成一个</param>
            <returns>复制过后的目标对象</returns>
        </member>
        <member name="T:DotNEToolkit.Parallel">
            <summary>
            并行操作的封装
            </summary>
        </member>
        <member name="T:DotNEToolkit.Parallel.ThreadContext">
            <summary>
            保存线程上下文信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Parallel.ThreadContext.ID">
            <summary>
            线程ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Parallel.ThreadContext.Task">
            <summary>
            线程所对应的Task
            </summary>
        </member>
        <member name="F:DotNEToolkit.Parallel.DefaultThreadNumber">
            <summary>
            默认开启5线程运行任务
            </summary>
        </member>
        <member name="M:DotNEToolkit.Parallel.Foreach``1(System.Collections.Generic.IList{``0},System.Int32,System.Action{``0,System.Object},System.Object,System.Action{System.Object})">
            <summary>
            对source集合进行并行操作
            该方法是异步的
            </summary>
            <typeparam name="T"></typeparam>
            <param name="threadNum">要开启的线程数量</param>
            <param name="source"></param>
            <param name="action"></param>
            <param name="userData"></param>
            <param name="callback">当所有action都运行完了之后的callback</param>
        </member>
        <member name="T:DotNEToolkit.ProcessUtils">
            <summary>
            提供进程相关的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessUtils.WaitForMainWindowHandleCreated(System.Diagnostics.Process,System.Int32)">
            <summary>
            等待某个进程的主窗口句柄创建成功
            </summary>
            <param name="proc"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessUtils.ClearExisting(System.Diagnostics.Process)">
            <summary>
            清空某个进程里的输出缓冲区里的数据
            </summary>
            <param name="proc">要清空的进程</param>
        </member>
        <member name="M:DotNEToolkit.ProcessUtils.KillProcess(System.String)">
            <summary>
            根据进程名字关闭一个进程
            </summary>
            <param name="procName">要关闭的进程名字，注意该进程名字不带后缀名（.exe）</param>
        </member>
        <member name="M:DotNEToolkit.ProcessUtils.CreateProcess(System.String,System.String)">
            <summary>
            创建一个标准输入输出都重定向了的进程
            </summary>
            <param name="exe"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DotNETCode">
            <summary>
            DotNEToolkit的返回值
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.UNKNOWN_EXCEPTION">
            <summary>
            异常
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FAILED">
            <summary>
            失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.SUCCESS">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.LOAD_CONFIG_FAILED">
            <summary>
            加载配置文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.INVALID_PARAMS">
            <summary>
            无效的参数
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.NOT_SUPPORTED">
            <summary>
            不支持的操作
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FILE_NOT_FOUND">
            <summary>
            文件不存在
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.READ_FAILED">
            <summary>
            读数据失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.WRITE_FAILED">
            <summary>
            写数据失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.TIMEOUT">
            <summary>
            操作超时
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.OPEN_FILE_FAILED">
            <summary>
            打开文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.SYS_ERROR">
            <summary>
            调用API失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.PARSE_CONFIG_FAILED">
            <summary>
            解析配置文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.MODULE_CIRCULAR_REFERENCE">
            <summary>
            模块与模块之间存在循环依赖关系
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.JSON_INVALID_FORMAT">
            <summary>
            无效的JSON格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FILE_WRITE_FAILED">
            <summary>
            写文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FILE_PERMISSION_ERROR">
            <summary>
            没有权限
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.IPC_SEND_FAILED">
            <summary>
            发送消息异常
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.CREATE_PROC_FAILED">
            <summary>
            创建进程失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.CREATE_HOSTED_MODULE_FAILED">
            <summary>
            创建IHostedModule失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.INIT_HOSTED_MODULE_FAILED">
            <summary>
            初始化IHostedModule失败
            </summary>
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc">
            <summary>
            参考：
            https://wiki.videolan.org/Documentation:Modules/marq/
            </summary>
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_media_open_cb">
            <summary>
            
            </summary>
            <param name="opaque">private pointer as passed to libvlc_media_new_callbacks()</param>
            <param name="datap">storage space for a private data pointer [OUT]</param>
            <param name="sizep">byte length of the bitstream or UINT64_MAX if unknown [OUT]</param>
            <returns>
            0 on success, non-zero on error. In case of failure, the other
            callbacks will not be invoked and any value stored in *datap and *sizep is
            discarded.
            </returns>
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_media_read_cb">
            <summary>
            
            </summary>
            <param name="opaque">private pointer as set by the @ref libvlc_media_open_cb callback</param>
            <param name="buf">start address of the buffer to read data into</param>
            <param name="len">bytes length of the buffer</param>
            <remarks>
            If no data is immediately available, then the callback should sleep.
            </remarks>
            <returns>
            strictly positive number of bytes read, 0 on end-of-stream, or -1 on non-recoverable error
            </returns>
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_media_seek_cb">
            <summary>
            Callback prototype to seek a custom bitstream input media.
            </summary>
            <param name="opaque">private pointer as set by the @ref libvlc_media_open_cb callback</param>
            <param name="offset">absolute byte offset to seek to</param>
            <returns>0 on success, -1 on error.</returns>
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_media_close_cb">
            <summary>
            Callback prototype to seek a custom bitstream input media.
            </summary>
            <param name="opaque">private pointer as set by the @ref libvlc_media_open_cb callback</param>
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_video_format_cb">
             Callback prototype to configure picture buffers format.
             This callback gets the format of the video as output by the video decoder
             and the chain of video filters (if any). It can opt to change any parameter
             as it needs. In that case, LibVLC will attempt to convert the video format
             (rescaling and chroma conversion) but these operations can be CPU intensive.
            
             \param opaque pointer to the private pointer passed to
                           libvlc_video_set_callbacks() [IN/OUT]
             \param chroma pointer to the 4 bytes video format identifier [IN/OUT]
             \param width pointer to the pixel width [IN/OUT]
             \param height pointer to the pixel height [IN/OUT]
             \param pitches table of scanline pitches in bytes for each pixel plane
                            (the table is allocated by LibVLC) [OUT]
             \param lines table of scanlines count for each plane [OUT]
             \return the number of picture buffers allocated, 0 indicates failure
            
             \note
             For each pixels plane, the scanline pitch must be bigger than or equal to
             the number of bytes per pixel multiplied by the pixel width.
             Similarly, the number of scanlines must be bigger than of equal to
             the pixel height.
             Furthermore, we recommend that pitches and lines be multiple of 32
             to not break assumptions that might be held by optimized code
             in the video decoders, video filters and/or video converters.
        </member>
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_video_cleanup_cb">
             Callback prototype to configure picture buffers format.
            
             \param opaque private pointer as passed to libvlc_video_set_callbacks()
                           (and possibly modified by @ref libvlc_video_format_cb) [IN]
        </member>
        <!-- Badly formed XML comment ignored for member "F:DotNEToolkit.SDK.libvlc.libvlc_video_logo_option_t.libvlc_logo_x" -->
        <member name="T:DotNEToolkit.SDK.libvlc.libvlc_video_marquee_option_t">
            <summary>
            每个枚举的使用方式参考：
            https://wiki.videolan.org/Documentation:Modules/marq/
            </summary>
        </member>
        <member name="F:DotNEToolkit.SDK.libvlc.libvlc_video_marquee_option_t.libvlc_marquee_Color">
            string argument 
        </member>
        <member name="M:DotNEToolkit.SDK.libvlc.libvlc_video_set_scale(System.IntPtr,System.Single)">
            <summary>
            Set the video scaling factor。
            Zero is a special value; it will adjust the video to the output
            window/drawable(in windowed mode) or the entire screen.
            </summary>
            <param name="player"></param>
            <param name="f_factor"></param>
        </member>
        <member name="M:DotNEToolkit.SDK.libvlc.libvlc_video_get_scale(System.IntPtr)">
            <summary>
            Get the current video scaling factor.
            </summary>
            <param name="player"></param>
            <returns>
            the currently configured zoom factor, or 0. if the video is set
            to fit to the output window/drawable automatically.
            </returns>
        </member>
        <member name="M:DotNEToolkit.SDK.libvlc.libvlc_video_set_logo_string(System.IntPtr,System.UInt32,System.Byte[])">
            <summary>
            
            </summary>
            <param name="p_mi"></param>
            <param name="option"></param>
            <param name="psz_value">utf8格式的字符串</param>
        </member>
        <member name="M:DotNEToolkit.SDK.libvlcHelper.EnableMouseEvent(System.IntPtr,System.Int32)">
            <summary>
            解决无法响应鼠标事件的问题
            </summary>
            <param name="hwnd">传递给vlc的视频播放窗口</param>
            <param name="delay">
            等待libvlc创建视频渲染窗口的延时时间</param>
        </member>
        <member name="T:DotNEToolkit.SingletonObject`1">
            <summary>
            表示一个单例对象
            </summary>
            <typeparam name="T">单例类的类型</typeparam>
        </member>
        <member name="T:DotNEToolkit.CellSpan">
            <summary>
            指定某个单元格的跨行方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.CellSpan.None">
            <summary>
            不跨行
            </summary>
        </member>
        <member name="F:DotNEToolkit.CellSpan.RowSpan">
            <summary>
            跨行
            </summary>
        </member>
        <member name="F:DotNEToolkit.CellSpan.ColSpan">
            <summary>
            跨列
            </summary>
        </member>
        <member name="T:DotNEToolkit.CellData">
            <summary>
            存储一个单元格的数据
            </summary>
        </member>
        <member name="P:DotNEToolkit.CellData.Row">
            <summary>
            该单元格所在行
            </summary>
        </member>
        <member name="P:DotNEToolkit.CellData.Column">
            <summary>
            单元格所在列
            </summary>
        </member>
        <member name="P:DotNEToolkit.CellData.Value">
            <summary>
            单元格的值
            </summary>
        </member>
        <member name="P:DotNEToolkit.CellData.SpanType">
            <summary>
            单元格的跨行或跨列方式
            </summary>
        </member>
        <member name="P:DotNEToolkit.CellData.Span">
            <summary>
            单元格跨了几个单元格
            </summary>
        </member>
        <member name="M:DotNEToolkit.CellData.#ctor">
            <summary>
            创建一个空的CellData
            </summary>
        </member>
        <member name="T:DotNEToolkit.TableData">
            <summary>
            描述表格类型的数据
            </summary>
        </member>
        <member name="M:DotNEToolkit.TableData.IsEmpty">
            <summary>
            返回该TableData是否为空
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.Set(System.Int32,System.Int32,System.Object)">
            <summary>
            设置某个单元格的值
            如果重复设置，那么会覆盖之前的值
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="value">该单元格的值</param>
        </member>
        <member name="M:DotNEToolkit.TableData.Set(System.Int32,System.Int32,DotNEToolkit.CellSpan,System.Int32,System.Object)">
            <summary>
            设置某个跨行或者跨列单元格的值
            如果重复设置，那么会覆盖之前的值
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="spanType"></param>
            <param name="span"></param>
            <param name="value">该单元格的值</param>
        </member>
        <member name="M:DotNEToolkit.TableData.Get(System.Int32,System.Int32)">
            <summary>
            读取某个单元格的值
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.Clear(System.Int32,System.Int32)">
            <summary>
            清除指定的单元格
            </summary>
            <param name="row">单元格所在行</param>
            <param name="col">单元格所在列</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.GetRows">
            <summary>
            获取从行数
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.GetColumns">
            <summary>
            获取总列数
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.GetRows(System.Int32)">
            <summary>
            获取某一列的总行数
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.GetColumns(System.Int32)">
            <summary>
            获取某一行的总列数
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.Merge(DotNEToolkit.TableData)">
            <summary>
            和tableData合并
            把tableData追加到该tableData下面
            </summary>
            <param name="tableData">要合并的tableData</param>
        </member>
        <member name="M:DotNEToolkit.TableData.Create">
            <summary>
            创建一个TableData的实例
            </summary>
            <returns>TableData实例</returns>
        </member>
        <member name="M:DotNEToolkit.TableData.ConvertToObjects``1">
            <summary>
            转换成ObjectList
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TableData.GetRowData(System.Int32)">
            <summary>
            获取一行里的所有数据
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.IDataResolver">
            <summary>
            TCP包头解析器。 
            
            TcpFramework假设每一次的TCP通讯总是以报文为单位。报文由报文头+报文内容组成。
            其中报文头的格式是固定，且长度固定。报文内容可以是不定长的，且报文头里总是包含报文内容长度信息。
            
            TcpFramework总是用固定长度的报文头缓冲（例如固定的20个字节）接收报文头。从而确定接下来
            需要接收的报文内容的长度。然后根据该长度来安排接下来的接收过程。接收事件的触发也总是尽量以接收到
            该次报文的所有字节后再触发（当报文内容长度大于最大缓冲大小时，同一个报文可能会触发多次接收事件）。
            因此TcpFramework的接收数据的过程总是周而复始的执行  
              1. 接收报文头  
              2. 接收报文内容(1次或多次)...
            
            在处理报文头的时候有2种情况：
              1. TcpFramework收到了正确的报文头。那么IDataResolver只需要根据约定的报文头格式解析出里面包含的报文长度即可
              2. 接收过程由于某种原因，收到的报文头发生了错位。一旦发生了错位，接下来所有正常的接收过程都会被打乱。
                 因此TcpFramework需要用某种方式来让接收过程重现回到正确的步骤上。这里有我们将采取断开客户端连接的方式解决
               
            IDataResolver接口所提供的主要功能就是
              1. 提供方法来验证报文头的正确性
              2. 确定报文内容的长度。
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.IDataResolver.ResolveHeader(System.Byte[],System.Int32)">
            <summary>
            解析TCP报文头. 
            根据业务逻辑所定义的TCP报文头格式来解析本次接收中接下来需要接收的TCP报文内容的长度
            </summary>
            <param name="headerBuffer">报文头缓冲</param>
            <param name="offset">本次分析的报文头的偏移</param>
            <returns>接下来需要接收报文的大小(整个报文减去报文头的长度)，返回小于0 说明接收到的报文头无效</returns>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.IDataResolver.HeaderSize">
            <summary>
            报文头的大小
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.NetEventArgs">
            <summary> 
            服务器程序的事件参数,包含了激发该事件的Socket对象 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.NetEventArgs.#ctor(System.Net.Sockets.Socket,System.Net.Sockets.SocketError)">
            <summary> 
            构造函数 
            </summary> 
            <param name="client">客户端会话</param> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.NetEventArgs.ClientSocket">
            <summary> 
            获得激发该事件的会话对象 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.NetEventArgs.ClientHandle">
            <summary>
            获取Socket的Handle
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.DataReceivedEventArgs">
            <summary>
            TCP数据接收事件参数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.Data">
            <summary>
            接收到的数据缓冲区
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.StartOffset">
            <summary>
            接收到的数据在缓冲区的起始位置
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.DataSize">
            <summary>
            接收到的数据长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.RemainSize">
            <summary>
            当前报文剩余字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.PackageIndex">
            <summary>
            如果message太大一次接收不完，该属性将记录
            接收该message时所触发回调的Index. 从0开始计数
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.Session">
            <summary> 
            客户端与服务器之间通讯的会话类。该会话类主要管理某个Socket接收事务，
            包括分包管理，缓冲区等等。
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.#ctor(System.Byte[],System.Int32)">
            <summary>
            构造接收通讯会话。Session中记录了TCP Message接收时需要保存的一些中间变量，如TCP Message的
            头，接收Message使用的缓冲区，剩余message的长度等等。为了减少内存碎片，Session在接收TCP 
            Message头时直接使用BufferManager预先分配的大块内存。然后再根据TCP Message头中定义的message
            长度，来动态决定下一次需要接收的数据大小，Socket接收缓冲区。接收完毕后，直接将缓冲区传递给上层应用，可以避免
            内存的复制。
            </summary>
            <param name="BufferOffset">session使用的缓冲区偏移</param>
            <param name="buffer">接收缓冲区</param>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.ID">
            <summary> 
            返回会话的ID. 小于0 则为未连接
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.RemoteEndPoint">
            <summary>
            远端接入点，用于调试或显示
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.ClientSocket">
            <summary> 
            获得与客户端会话关联的Socket对象 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.Remaining">
            <summary>
            本次处理的报文接收中剩余的字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.Expected">
            <summary>
            下一次接收期望的数据大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.DataInBuffer">
            <summary>
            当前buffer里保存的数据长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.PackageIndex">
            <summary>
            如果一个message过大，一次接收不完。
            该字段记录已经接收的该message并触发回调的次数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.ReceiveBuffer">
            <summary>
            Message缓冲区
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.BufferOffset">
            <summary>
            在接收下一次数据时，应该从该偏移位置保存接收到的数据。
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.EmptyMsgCount">
            <summary>
            记录连续收到的空消息事件记录. 在很多情况下，当远端socket断开时，
            异步接收函数不会收到ConnectionReset错误。而是直接返回空消息。如果服务器连续n次接收到空消息，
            那么可以认为远端Socket已经断开。
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.SetSocket(System.Net.Sockets.Socket)">
            <summary>
            设置Session关联的Socket
            </summary>
            <param name="cliSocket"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.Close">
            <summary> 
            关闭会话 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.GetHashCode">
            <summary> 
            使用Socket对象的Handle值作为HashCode,它具有良好的线性特征. 
            </summary> 
            <returns></returns> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.Equals(System.Object)">
            <summary> 
            返回两个Session是否代表同一个客户端 
            </summary> 
            <param name="obj"></param> 
            <returns></returns> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.ToString">
            <summary> 
            重载ToString()方法,返回Session对象的特征 
            </summary> 
            <returns></returns> 
        </member>
        <member name="T:DotNEToolkit.TcpFramework.SessionManager">
            <summary>
            SessionManager主要用于管理和回收服务器，客户端直接通讯的Session。
            为减少内存碎片，提高效率，SessionManager将预先分配一大块内存区域作为缓冲，供多个Session同时使用。
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.blockSize">
            <summary>
            每片message头的大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.freeSessions">
            <summary>
            记录可用的bufferIndex. 如果freeSessions有Size限制，
            可以考虑使用freeBufferStack来减少内存消耗
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.buffer">
            <summary>
            缓冲区
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.unusedOffset">
            <summary>
            已分配出的buffer offset
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.#ctor(System.Int32,System.Int32)">
            <summary>
            初始化函数
            </summary>
            <param name="max">最大的缓冲数量</param>
            <param name="blockSize">每个缓冲区的大小</param>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SessionManager.Buffer">
            <summary>
            报文头接收缓冲
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SessionManager.BlockSize">
            <summary>
            每片缓冲长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SessionManager.Capacity">
            <summary>
            可以支持的session最大数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.RequestSession(System.Net.Sockets.Socket)">
            <summary>
            申请一个会话对象
            </summary>
            <param name="cliSock">通讯Socket</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.ReleaseSession(DotNEToolkit.TcpFramework.Session)">
            <summary>
            回收会话对象
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.Clear">
            <summary>
            重置BufferManager
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool">
            <summary>
            基于MSDN的SocketAsyncEventArgs的例子 http://msdn2.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.socketasynceventargs.aspx
            对 SocketAsyncEventArgs进行重用管理，防止GC回收无用的SocketAsyncEventArgs，浪费系统资源
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.pool">
            <summary>
            SocketAsyncEventArgs栈
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.Count">
            <summary>
            返回SocketAsyncEventArgs池中的 数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.#ctor(System.Int32)">
            <summary>
            初始化SocketAsyncEventArgs池
            </summary>
            <param name="capacity">最大可能使用的SocketAsyncEventArgs对象.</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.Pop">
            <summary>
            弹出一个SocketAsyncEventArgs
            </summary>
            <returns>SocketAsyncEventArgs removed from the pool.</returns>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.Push(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            添加一个 SocketAsyncEventArgs
            </summary>
            <param name="item">SocketAsyncEventArgs instance to add to the pool.</param>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.TcpCli">
            <summary> 
            提供Tcp网络连接服务的客户端类 
            1.使用异步的Socket通讯函数BeginXXX作为基础，完成网络通讯功能。
              接收与发送过程相互不干扰，实现了TCP全双工。
            2.客户端连接服务成功后，将立刻启动接收过程。每次接收首先接收Message头，然后根据
              报文头解析出来的剩余报文长度，安排一次或者多次的接收。由此来处理分包问题。当报文的长度
              小于可以接受的缓冲区大小时，服务类将会等收到所有报文后触发数据接收事件；否则服务类将会
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.DefaultBufferSize">
            <summary> 
            缺省接收数据缓冲区大小8K 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.DefaultMaxEmptyMessage">
            <summary>
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.session">
            <summary> 
            接收数据会话 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.receiveBuffer">
            <summary>
            receive buffer
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.headerResolver">
            <summary>
            头部解析
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.dataReceivedCallback">
            <summary>
            接收数据回调Callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.dataSentCallback">
            <summary>
            data sent callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.#ctor(DotNEToolkit.TcpFramework.IDataResolver,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="headerSize">约定的TCP Message头大小</param>
            <param name="headerResolver">报文头解析函数</param>
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.Connected">
            <summary> 
            已连接事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.Disconnected">
            <summary> 
            连接断开事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.DataReceived">
            <summary> 
            接收到数据报文事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.DataSent">
            <summary>
            发送结束
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpCli.IsConnected">
            <summary> 
            返回客户端与服务器之间的连接状态 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpCli.MaxEmptyMessage">
            <summary>
            如果某个clientSocket                                     
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.BeginConnect(System.String,System.Int32)">
            <summary> 
            连接服务器 
            </summary> 
            <param name="ip">服务器IP地址</param> 
            <param name="port">服务器端口</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.SendAsync(System.Byte[])">
            <summary> 
            发送数据报文 
            </summary> 
            <param name="datagram"></param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.Disconnect">
            <summary> 
            关闭连接 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.Close(System.Net.Sockets.SocketError)">
            <summary>
            内部调用。会触发断开事件
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.OnDataSent(System.IAsyncResult)">
            <summary> 
            数据发送完成处理函数 
            </summary> 
            <param name="iar"></param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.OnConnected(System.IAsyncResult)">
            <summary> 
            建立Tcp连接后处理过程 
            </summary> 
            <param name="iar">异步Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.OnDataReceived(System.IAsyncResult)">
            <summary> 
            数据接收处理函数 
            </summary> 
            <param name="iar">异步Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.ReceiveData(DotNEToolkit.TcpFramework.Session,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            接收数据
            </summary>
            <param name="session"></param>
            <param name="dataInBuffer">当前buffer已有的数据长度</param>
            <param name="expectedSize">期望接收的数据大小</param>
            <param name="packageIndex">下一次接收的包</param>
            <param name="remaining">当前会话剩余的字节数</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.ResumeLastReceive(DotNEToolkit.TcpFramework.Session)">
            <summary>
            根据当前记录重试上次的任务
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.ResolveHeader(DotNEToolkit.TcpFramework.Session)">
            <summary>
            解析报文头
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.HandleData(DotNEToolkit.TcpFramework.Session,System.Int32)">
            <summary>
            处理收到的报文数据
            </summary>
            <param name="session"></param>
            <param name="receivedSize"></param>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.TcpSvr">
            <summary> 
            提供TCP连接服务的服务器类。 
            
            1. 使用异步的Socket事件作为基础，完成全双工的网络通讯功能. 
            2. 该服务类每次Accept客户端连接后，将立刻启动接收过程。每次接收首先接收Message头，然后根据
               报文头解析出来的剩余报文长度，安排一次或者多次的接收。由此来处理分包问题。当报文的长度
               小于可以接受的缓冲区大小时，服务类将会等收到所有报文后触发数据接收事件；否则服务类将会
               触发多次数据接收事件，直至报文接收完成。然后进入下一次接收状态。
            3. 服务类发送时也是用异步发送过程。与发送过程相互不干扰。
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultConcurrentLevel">
            <summary>
            默认并发级别，即同一时刻访问sessionTable的并发线程数。
            请参考ConcurrentDictionary concurrentLevel定义。
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultMaxClient">
            <summary> 
            默认的服务器最大连接客户端端数据 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultHeaderSize">
            <summary> 
            缺省Header大小8K 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultBacklog">
            <summary>
            TCP Listen backlog
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultBufferSize">
            <summary>
            接收缓冲最大大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultMaxEmptyMessage">
            <summary>
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.concurrentLevel">
            <summary>
            并发级别。定义为同一时刻访问sessionTable的并发线程数。
            请参考ConcurrentDictionary concurrentLevel定义。
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.dataReceivedCallback">
            <summary>
            接收数据回调Callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.connectionAcceptedCallback">
            <summary>
            connection Accepted callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.dataSentCallback">
            <summary>
            data sent callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.serverIP">
            <summary>
            服务器程序监听的IP地址
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.port">
            <summary> 
            服务器程序使用的端口 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.isRun">
            <summary> 
            服务器的运行状态 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.listenSocket">
            <summary> 
            服务器使用的异步Socket类, 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.sessionTable">
            <summary> 
            保存所有客户端会话的哈希表 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.sessionManager">
            <summary>
            Session Manager
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.headerResolver">
            <summary>
            TCP数据解析器
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.#ctor(System.Net.IPAddress,System.UInt16,DotNEToolkit.TcpFramework.IDataResolver,System.Int32,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="ipAddress">服务IP</param>
            <param name="port">服务器端监听的端口号</param>
            <param name="headerResolver">报文头解析函数</param>
            <param name="maxClient">服务器最大容纳客户端数</param>
            <param name="headerSize">报文头长度</param>
            <param name="maxRecvBufSize">每次接收报文的最大大小</param>
            <param name="concurrentLevel">服务器并发度。主要体现在Listener的backlog以及sessionMap的并发级别</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.#ctor(System.String,System.UInt16,DotNEToolkit.TcpFramework.IDataResolver,System.Int32,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="ipAddress">服务IP</param>
            <param name="port">服务器端监听的端口号</param>
            <param name="headerResolver">报文头解析函数</param>
            <param name="maxClient">服务器最大容纳客户端数</param>
            <param name="headerSize">报文头长度</param>
            <param name="maxRecvBufSize">每次接收报文的最大大小</param>
            <param name="concurrentLevel">服务器并发度。主要体现在Listener的backlog以及sessionMap的并发级别</param>
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.ClientConnected">
            <summary> 
            客户端建立连接事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.ClientClosed">
            <summary> 
            客户端关闭事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.ServerFull">
            <summary> 
            服务器已经满事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.DataReceived">
            <summary> 
            服务器接收到数据事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.DataSent">
            <summary>
            数据发送结束
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.ServerSocket">
            <summary> 
            服务器的Socket对象 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.Capacity">
            <summary> 
            服务器可以容纳客户端的最大能力 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.SessionCount">
            <summary> 
            当前的客户端连接数 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.IsRun">
            <summary> 
            服务器运行状态 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.MaxEmptyMessage">
            <summary>
            如果某个clientSocket                                     
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.Start">
            <summary> 
            启动服务器程序,开始监听客户端请求 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.Stop">
            <summary> 
            停止服务器程序,所有与客户端的连接将关闭 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.CloseAllClient">
            <summary> 
            关闭所有的客户端会话,与所有的客户端连接会断开。
            该命令将不触发ClientClosed事件
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.CloseClient(System.Int32)">
            <summary> 
            关闭一个与客户端之间的会话 
            </summary> 
            <param name="clientSocket">需要关闭的客户端会话对象</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.SendAsync(System.Int32,System.Byte[])">
            <summary> 
            发送数据 
            </summary> 
            <param name="clientSession">接收数据的客户端会话</param> 
            <param name="datagram">数据报文</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.GetClientSocket(System.Int32)">
            <summary>
            获取Client Socket
            </summary>
            <param name="clientHandle"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.Initialize(System.Net.IPAddress,System.UInt16,DotNEToolkit.TcpFramework.IDataResolver,System.Int32,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="ipAddress">服务IP</param>
            <param name="port">服务器端监听的端口号</param>
            <param name="headerResolver">报文头解析函数</param>
            <param name="maxClient">服务器最大容纳客户端数</param>
            <param name="recvBufSize">接收缓冲的大小</param>
            <param name="concurrentLevel">服务器并发度。主要体现在Listener的backlog以及sessionMap的并发级别</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.OnConnectionAccepted(System.IAsyncResult)">
            <summary> 
            客户端连接处理函数 
            </summary> 
            <param name="iar">欲建立服务器连接的Socket对象</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.OnDataReceived(System.IAsyncResult)">
            <summary> 
            接受数据完成处理函数. 接收到报文后，server首先判断session当前的状态：
            1. 接收报文头的状态（Session.Remaining==0）: 
               服务将调用headerResolver解析报文头部，确定接下来的报文大小。同时创建接收缓冲。
            2. 接收报文状态(Session.Remaining>0)：
               收到报文。服务将触发接收报文事件
            
            </summary> 
            <param name="iar">目标客户端Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.OnDataSent(System.IAsyncResult)">
            <summary> 
            发送数据完成处理函数 
            </summary> 
            <param name="iar">目标客户端Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.CloseSession(DotNEToolkit.TcpFramework.Session,System.Net.Sockets.SocketError)">
            <summary> 
            关闭一个客户端Session. 
            </summary> 
            <param name="session">目标session对象</param> 
            <param name="errorCode">客户端退出的SocketError Code</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.FindSession(System.Int32)">
            <summary> 
            通过Socket对象查找ClientSocket对象 
            </summary> 
            <param name="client"></param> 
            <returns>找到的Session对象,如果为null,说明并不存在该回话</returns> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.ResolveHeader(DotNEToolkit.TcpFramework.Session)">
            <summary>
            解析报文头
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.HandleData(DotNEToolkit.TcpFramework.Session,System.Int32)">
            <summary>
            处理收到的报文数据
            </summary>
            <param name="session"></param>
            <param name="receivedSize"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.ReceiveData(DotNEToolkit.TcpFramework.Session,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            接收数据
            </summary>
            <param name="session"></param>
            <param name="dataInBuffer">当前buffer已有的数据长度</param>
            <param name="expectedSize">期望接收的数据大小</param>
            <param name="packageIndex">下一次接收的包</param>
            <param name="remaining">当前会话剩余的字节数</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.ResumeLastReceive(DotNEToolkit.TcpFramework.Session)">
            <summary>
            根据当前记录重试上次的任务
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.Win32APIHelper.GetWindowText(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            获取某个窗口中，某个位置的控件上的文本
            </summary>
            <param name="hWnd">要获取的窗口的句柄</param>
            <param name="x">要获取文本的控件的x坐标</param>
            <param name="y">要获取文本的控件的y坐标</param>
            <returns>获取到的文本</returns>
        </member>
        <member name="M:DotNEToolkit.Win32APIHelper.ShowFileProperties(System.String)">
            <summary>
            显示文件或者目录的属性对话框
            </summary>
            <param name="Filename"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.Iphlpapi.TCP_TABLE_CLASS.TCP_TABLE_BASIC_ALL">
            <summary>
            MIB_TCPTABLE
            </summary>
        </member>
        <member name="F:DotNEToolkit.Iphlpapi.TCP_TABLE_CLASS.TCP_TABLE_OWNER_MODULE_ALL">
            <summary>
            MIB_TCPTABLE_OWNER_MODULE
            </summary>
        </member>
        <member name="F:DotNEToolkit.Iphlpapi.TCP_TABLE_CLASS.TCP_TABLE_OWNER_PID_ALL">
            <summary>
            MIB_TCPTABLE_OWNER_PID
            </summary>
        </member>
        <member name="F:DotNEToolkit.Iphlpapi.MIB_TCPTABLE_OWNER_MODULE.dwNumEntries">
            <summary>
            The number of MIB_TCPROW_OWNER_MODULE elements in the table.
            </summary>
        </member>
        <member name="F:DotNEToolkit.Iphlpapi.MIB_TCPTABLE_OWNER_MODULE.table">
            <summary>
            Array of MIB_TCPROW_OWNER_MODULE structures returned by a call to GetExtendedTcpTable.
            </summary>
        </member>
        <member name="M:DotNEToolkit.Kernel32.LoadLibrary(System.String)">
            <summary>
            加载动态链接库
            </summary>
            <param name="dllToLoad">dll文件名</param>
            <returns>dll模块指针</returns>
        </member>
        <member name="M:DotNEToolkit.Kernel32.GetProcAddress(System.IntPtr,System.String)">
            <summary>
            获取函数指针
            </summary>
            <param name="hModule">dll模块指针</param>
            <param name="procedureName">方法名</param>
            <returns>函数指针</returns>
        </member>
        <member name="M:DotNEToolkit.Kernel32.FreeLibrary(System.IntPtr)">
            <summary>
            释放动态链接库
            </summary>
            <param name="hModule">dll模块指针</param>
            <returns>释放释放成功</returns>
        </member>
        <member name="T:DotNEToolkit.MMSYSERR">
            <summary>
            返回值定义
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.lpData">
            <summary>
            Pointer to the waveform buffer.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.dwBufferLength">
            <summary>
            Length, in bytes, of the buffer.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.dwBytesRecorded">
            <summary>
            When the header is used in input, specifies how much data is in the buffer.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.dwUser">
            <summary>
            User data.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.uMsgEnum.WIM_CLOSE">
            <summary>
            Sent when the device is closed using the waveInClose function.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.uMsgEnum.WIM_DATA">
            <summary>
            Sent when the device driver is finished with a data block sent using the waveInAddBuffer function.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.uMsgEnum.WIM_OPEN">
            <summary>
            Sent when the device is opened using the waveInOpen function.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_EVENT">
            <summary>
            The dwCallback parameter is an event handle.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_FUNCTION">
            <summary>
            The dwCallback parameter is a callback procedure address.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_NULL">
            <summary>
            No callback mechanism. This is the default setting.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_THREAD">
            <summary>
            The dwCallback parameter is a thread identifier.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_WINDOW">
            <summary>
            The dwCallback parameter is a window handle.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.WAVE_FORMAT_DIRECT">
            <summary>
            If this flag is specified, the ACM driver does not perform conversions on the audio data.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.WAVE_FORMAT_QUERY">
            <summary>
            The function queries the device to determine whether it supports the given format, but it does not open the device.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.WAVE_MAPPED">
            <summary>
            The uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper.
            </summary>
        </member>
        <member name="T:DotNEToolkit.waveIn.waveInProcDlg">
            <summary>
            
            </summary>
            <param name="hwi"></param>
            <param name="uMsg"></param>
            <param name="dwInstance"></param>
            <param name="dwParam1">wavehdr_tag指针</param>
            <param name="dwParam2"></param>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInGetNumDevs">
            <summary>
            获取音频输入设备的数量
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInOpen(System.IntPtr@,System.UInt32,System.IntPtr,DotNEToolkit.waveIn.waveInProcDlg,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="phwi">用于返回设备句柄的指针; 如果 dwFlags=WAVE_FORMAT_QUERY, 这里应是 NULL</param>
            <param name="uDeviceID">设备ID; 可以指定为: WAVE_MAPPER, 这样函数会根据给定的波形格式选择合适的设备</param>
            <param name="pwfx">要申请的声音格式</param>
            <param name="dwCallback">回调函数地址或窗口句柄; 若不使用回调机制, 设为 NULL</param>
            <param name="dwInstance">给回调函数的实例数据; 不用于窗口</param>
            <param name="fdwOpen">打开选项</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInClose(System.IntPtr)">
            <summary>
            The waveInClose function closes the given waveform-audio input device.
            </summary>
            <param name="phwi"></param>
            <remarks>
            If there are input buffers that have been sent with the waveInAddBuffer function and that haven't been returned to the application, the close operation will fail. Call the waveInReset function to mark all pending buffers as done.
            为了确保关闭成功, 要在调用waveInClose之前先调用waveInReset
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInPrepareHeader(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            The waveInPrepareHeader function prepares a buffer for waveform-audio input.
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="pwh">WAVEHDR（wavehdr_tag）结构体指针</param>
            <param name="cbwh">Size, in bytes, of the WAVEHDR structure.</param>
            <remarks>
            The lpData, dwBufferLength, and dwFlags members of the WAVEHDR structure must be set before calling this function (dwFlags must be zero).
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInAddBuffer(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            The waveInAddBuffer function sends an input buffer to the given waveform-audio input device. When the buffer is filled, the application is notified.
            把准备好的缓冲区送给硬件
            </summary>
            <param name="hwi"></param>
            <param name="pwh">waveHeader指针</param>
            <param name="cbwh"></param>
            <remarks>
            When the buffer is filled, the WHDR_DONE bit is set in the dwFlags member of the WAVEHDR structure.
            The buffer must be prepared with the waveInPrepareHeader function before it is passed to this function.
            在调用waveInAddBuffer之前必须调用waveInPrepareHeader函数
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInUnprepareHeader(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="hwi"></param>
            <param name="pwh">waveHeader指针</param>
            <param name="cbwh"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.Win32API.WAIT_FAILED">
            <summary>
            等待信号失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.WAVE_FORMAT_PCM">
            <summary>
            flags for wFormatTag field of WAVEFORMAT
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.WM_APPCOMMAND">
            <summary>
            https://docs.microsoft.com/zh-cn/windows/win32/inputdev/wm-appcommand?redirectedfrom=MSDN
            使用WM_APPCOMMAND消息可以实现键盘上的多媒体按键（比如音量控制）
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.APPCOMMAND_CLOSE">
            <summary>
            Close the window (not the application).
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.APPCOMMAND_MICROPHONE_VOLUME_DOWN">
            <summary>
            Decrease microphone volume.
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.APPCOMMAND_MICROPHONE_VOLUME_MUTE">
            <summary>
            Mute the microphone.
            </summary>
        </member>
        <member name="M:DotNEToolkit.Win32API.UpdateWindow(System.IntPtr)">
            <summary>
            立即刷新某个窗口
            会导致窗口重绘
            </summary>
            <param name="hWnd"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.ChildWindowFromPoint(System.IntPtr,DotNEToolkit.Win32API.POINT)">
            <summary>
            返回父窗口中包含了指定点的第一个子窗口的句柄
            </summary>
            <param name="hWndParent"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WindowFromPoint(DotNEToolkit.Win32API.POINT)">
            <summary>
            返回指定坐标处的窗口句柄
            </summary>
            <param name="Point"></param>
            <returns>如果找到了窗口，则返回窗口句柄，否则返回空句柄</returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.ShellExecute(System.IntPtr,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            ShellExecute(IntPtr.Zero, "Open", "C:/Program Files/TTPlayer/TTPlayer.exe", "", "", 1);
            </summary>
            <param name="hwnd"></param>
            <param name="lpOperation"></param>
            <param name="lpFile"></param>
            <param name="lpParameters"></param>
            <param name="lpDirectory"></param>
            <param name="nShowCmd"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.DirectSoundCaptureCreate8(System.IntPtr,System.IntPtr@,System.IntPtr)">
            <summary>
            创建一个DirectSoundCapture8接口
            </summary>
            <param name="pcGuidDevice"></param>
            <param name="ppDSC8"></param>
            <param name="pUnkOuter"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.DirectSoundCreate8(System.IntPtr,System.IntPtr@,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="lpcGuidDevice">
            Address of the GUID that identifies the sound device
            DSDEVID_DefaultPlayback : System-wide default audio playback device. Equivalent to NULL. 
            DSDEVID_DefaultVoicePlayback : Default voice playback device. 
            </param>
            <param name="ppDS8">Address of a variable to receive an IDirectSound8 interface pointer. </param>
            <param name="pUnkOuter"></param>
            <returns></returns>
            <remarks>
            在创建IDirectSound8接口之后必须首先调用SetCooperativeLevel
            </remarks>
        </member>
        <member name="T:DotNEToolkit.Win32API.DSEnumCallback">
            <summary>
            注意：第一个被枚举出来的设备永远都是Primary Sound Driver（主声音捕获设备），所以一般情况下都会忽略第一个设备。主声音捕获设备的意思就是当前用户选择的录音设备。
            The first device enumerated is always called the Primary Sound Driver, and the lpGUID parameter of the callback is NULL. This device represents the preferred playback device set by the user in Control Panel
            </summary>
            <param name="lpGuid">Address of the GUID that identifies the device being enumerated, or NULL for the primary device. This value can be passed to the DirectSoundCreate8 or DirectSoundCaptureCreate8 function to create a device object for that driver.</param>
            <param name="lpcstrDescription">Address of a null-terminated string that provides a textual description of the DirectSound device.</param>
            <param name="lpcstrModule">Address of a null-terminated string that specifies the module name of the DirectSound driver corresponding to this device.</param>
            <param name="lpContext">Address of application-defined data. This is the pointer passed to DirectSoundEnumerate or DirectSoundCaptureEnumerate as the lpContext parameter.</param>
            <returns>Returns TRUE to continue enumerating drivers, or FALSE to stop.</returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.DirectSoundCaptureEnumerate(DotNEToolkit.Win32API.DSEnumCallback,System.Object)">
            <summary>
            DirectSound枚举声音捕获设备的接口
            </summary>
            <param name="lpDSEnumCallback">枚举回调</param>
            <param name="lpContext">上下文信息</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WaitForMultipleObjects(System.Int32,System.IntPtr,System.Boolean,System.UInt32)">
            <summary>
            
            </summary>
            <param name="nCount">指定列表中的句柄数量  最大值为MAXIMUM_WAIT_OBJECTS（64）</param>
            <param name="lpHandles">柄数组的指针。lpHandles为指定对象句柄组合中的第一个元素 HANDLE类型可以为（Event，Mutex，Process，Thread，Semaphore）数组</param>
            <param name="bWaitAll">如果为TRUE，表示除非对象都发出信号，否则就一直等待下去；如果FALSE，表示任何对象发出信号即可</param>
            <param name="dwMilliseconds">指定要等候的毫秒数。如设为零，表示立即返回。如指定常数INFINITE，则可根据实际情况无限等待下去</param>
            <returns>
            WAIT_ABANDONED_0：所有对象都发出消息，而且其中有一个或多个属于互斥体（一旦拥有它们的进程中止，就会发出信号）
            WAIT_TIMEOUT：对象保持未发信号的状态，但规定的等待超时时间已经超过
            WAIT_OBJECT_0：所有对象都发出信号，WAIT_OBJECT_0是微软定义的一个宏，你就把它看成一个数字就可以了。例如，WAIT_OBJECT_0 + 5的返回结果意味着列表中的第5个对象发出了信号
            WAIT_IO_COMPLETION：（仅适用于WaitForMultipleObjectsEx）由于一个I/O完成操作已作好准备执行，所以造成了函数的返回
            返回WAIT_FAILED则表示函数执行失败，会设置GetLastError
            </returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WaitForSingleObject(System.IntPtr,System.UInt32)">
            <summary>
            等待信号量
            </summary>
            <param name="evt"></param>
            <param name="dwMilliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.ResetEvent(System.IntPtr)">
            <summary>
            重置信号量为无信号状态
            </summary>
            <param name="hEvent"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.GetPrivateProfileString(System.String,System.String,System.String,System.Text.StringBuilder,System.Int32,System.String)">
            <summary>
            Ini文件读取
            </summary>
            <param name="section"></param>
            <param name="key"></param>
            <param name="def"></param>
            <param name="retVal"></param>
            <param name="size"></param>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WritePrivateProfileString(System.String,System.String,System.String,System.String)">
            <summary>
            Ini文件写入
            </summary>
            <param name="section"></param>
            <param name="key"></param>
            <param name="val"></param>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.User32">
            <summary>
            WinUser.h
            </summary>
        </member>
        <member name="M:DotNEToolkit.User32.RegisterDeviceNotification(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="hRecipient"></param>
            <param name="NotificationFilter"></param>
            <param name="Flags">
            DEVICE_NOTIFY_ALL_INTERFACE_CLASSES：Notifies the recipient of device interface events for all device interface classes. (The dbcc_classguid member is ignored.)This value can be used only if the dbch_devicetype member is DBT_DEVTYP_DEVICEINTERFACE.
            </param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.User32.UnregisterDeviceNotification(System.IntPtr)">
            <summary>
            Closes the specified device notification handle.
            </summary>
            <param name="Handle">Device notification handle returned by the RegisterDeviceNotification function.</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Dbt">
            <summary>
            Dbt.h
            </summary>
        </member>
        <member name="T:DotNEToolkit.SetupAPI">
            <summary>
            SetupAPI.h
            </summary>
        </member>
        <member name="T:DotNEToolkit.imm">
            <summary>
            imm.h
            </summary>
        </member>
        <member name="T:DotNEToolkit.CLSID">
            <summary>
            COM类型ID
            </summary>
        </member>
        <member name="T:DotNEToolkit.InterfaceID">
            <summary>
            COM接口ID
            </summary>
        </member>
        <member name="T:DotNEToolkit.WindowsServices">
            <summary>
            管理Windows服务
            </summary>
        </member>
        <member name="M:DotNEToolkit.WindowsServices.StartService(System.String)">
            <summary>
            启动一个Windows服务
            </summary>
            <param name="svcName">要启动的服务名字</param>
            <returns>
            启动成功返回true
            如果没找到服务或者启动失败则返回false
            </returns>
        </member>
        <member name="M:DotNEToolkit.WindowsServices.StopService(System.String)">
            <summary>
            停止一个Windows服务
            </summary>
            <param name="svcName">要停止的服务名字</param>
            <returns>
            停止成功返回true
            如果没找到服务或者停止失败则返回false
            </returns>
        </member>
        <member name="M:DotNEToolkit.XmlHelper.ParseFromFile``1(System.String)">
            <summary>
            Parse xml from file path
            </summary>
            <typeparam name="ITEM"></typeparam>
            <param name="filePath"></param>
            <returns></returns>
            <remarks>It is caller's responsibility to catch exception</remarks>
        </member>
        <member name="M:DotNEToolkit.XmlHelper.ToXmlString``1(``0,System.Xml.XmlWriterSettings,System.Xml.Serialization.XmlSerializerNamespaces)">
            <summary>
            Serialize object to xml string
            </summary>
            <typeparam name="ITEM"></typeparam>
            <param name="item"></param>
            <returns></returns>
            <remarks>It is caller's responsibility to catch exception</remarks>
        </member>
        <member name="M:DotNEToolkit.XmlHelper.ToXmlFile``1(``0,System.String)">
            <summary>
            Serialize an object to xml file
            </summary>
            <typeparam name="ITEM"></typeparam>
            <param name="item"></param>
            <param name="filePath"></param>
            <remarks>It is caller's responsibility to catch exception</remarks>
        </member>
    </members>
</doc>
